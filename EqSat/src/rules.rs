// Code generated by "EggBackend.cs"; DO NOT EDIT.
#![allow(warnings)]
use egg::{rewrite, Applier, Id, PatternAst, Subst, Symbol, Var};

use crate::simple_ast::{
    as_constant, const_eq, eqmod, get_const, get_known_zeroes, get_width, is_const, popcount,
    AstData, EEGraph, MbaAnalysis, Predicate, Rewrite, SimpleAst,
};

pub fn get_generated_rules() -> Vec<Rewrite> {
    vec![
        // (a:i64|b:i64) => (b:i64|a:i64)
        rewrite!("or_commutativity"; "(| ?a ?b)" => {
            applier_rule_or_commutativity {
                b : "?b".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        }),
        // (a:i64|(b:i64|c:i64)) => ((a:i64|b:i64)|c:i64)
        rewrite!("or_associativity"; "(| ?a (| ?b ?c))" => {
            applier_rule_or_associativity {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64^b:i64) => (b:i64^a:i64)
        rewrite!("xor_commutativity"; "(^ ?a ?b)" => {
            applier_rule_xor_commutativity {
                b : "?b".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        }),
        // (a:i64^(b:i64^c:i64)) => ((a:i64^b:i64)^c:i64)
        rewrite!("xor_associativity"; "(^ ?a (^ ?b ?c))" => {
            applier_rule_xor_associativity {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64&b:i64) => (b:i64&a:i64)
        rewrite!("and_commutativity"; "(& ?a ?b)" => {
            applier_rule_and_commutativity {
                b : "?b".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        }),
        // (a:i64&(b:i64&c:i64)) => ((a:i64&b:i64)&c:i64)
        rewrite!("and_associativity"; "(& ?a (& ?b ?c))" => {
            applier_rule_and_associativity {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64*b:i64) => (b:i64*a:i64)
        rewrite!("mul_commutativity"; "(* ?a ?b)" => {
            applier_rule_mul_commutativity {
                b : "?b".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        }),
        // (a:i64*(b:i64*c:i64)) => ((a:i64*b:i64)*c:i64)
        rewrite!("mul_associativity"; "(* ?a (* ?b ?c))" => {
            applier_rule_mul_associativity {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64*(b:i64+c:i64)) => ((a:i64*b:i64)+(a:i64*c:i64))
        rewrite!("mul_distributivity"; "(* ?a (+ ?b ?c))" => {
            applier_rule_mul_distributivity {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // ((a:i64&b:i64)|(a:i64&c:i64)) => (a:i64&(b:i64|c:i64))
        rewrite!("and_or_factor"; "(| (& ?a ?b) (& ?a ?c))" => {
            applier_rule_and_or_factor {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64&(b:i64|c:i64)) => ((a:i64&b:i64)|(a:i64&c:i64))
        rewrite!("and_or_distributivity"; "(& ?a (| ?b ?c))" => {
            applier_rule_and_or_distributivity {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // ((a:i64|b:i64)&(a:i64|c:i64)) => (a:i64|(b:i64&c:i64))
        rewrite!("or_and_factor"; "(& (| ?a ?b) (| ?a ?c))" => {
            applier_rule_or_and_factor {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64|(b:i64&c:i64)) => ((a:i64|b:i64)&(a:i64|c:i64))
        rewrite!("or_and_distributivity"; "(| ?a (& ?b ?c))" => {
            applier_rule_or_and_distributivity {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (((a1:i64&c1:i64)==mconst0:i64)^((a2:i64&c1:i64)!=mconst0:i64)) => ((((~a1:i64)&c1:i64)^(a2:i64&c1:i64))!=0:i64)
        rewrite!("cmp_i1_combine"; "(^ (\"icmp ==\" (& ?a1 ?c1) ?mconst0) (\"icmp !=\" (& ?a2 ?c1) ?mconst0))" => {
            applier_rule_cmp_i1_combine {
                a1 : "?a1".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                a2 : "?a2".parse().unwrap(),
            }
        } if (rule_cmp_i1_combine_precondition("?c1", "?mconst0"))),
        // (((x:i64&c1:i64)!=mconst0:i64)^((c1:i64&y:i64)!=mconst0:i64)) => (((x:i64^y:i64)&c1:i64)!=0:i64)
        rewrite!("cmp_xor_i1_combine"; "(^ (\"icmp !=\" (& ?x ?c1) ?mconst0) (\"icmp !=\" (& ?c1 ?y) ?mconst0))" => {
            applier_rule_cmp_xor_i1_combine {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
            }
        } if (rule_cmp_xor_i1_combine_precondition("?c1", "?mconst0"))),
        // (((~x:i64)&c1:i64)!=mconst0:i64) => ((x:i64&c1:i64)==0:i64)
        rewrite!("neg_neq_to_eq"; "(\"icmp !=\" (& (~ ?x) ?c1) ?mconst0)" => {
            applier_rule_neg_neq_to_eq {
                x : "?x".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
            }
        } if (rule_neg_neq_to_eq_precondition("?c1", "?mconst0"))),
        // ((a:i64>>c1:i64)>>c2:i64) => (a:i64>>(c1:i64+c2:i64))
        rewrite!("lshr_const_fold"; "(>> (>> ?a ?c1) ?c2)" => {
            applier_rule_lshr_const_fold {
                a : "?a".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        }),
        // ((a:i64>>c:i64)&(b:i64>>c:i64)) => ((a:i64&b:i64)>>c:i64)
        rewrite!("lshr_and_combine"; "(& (>> ?a ?c) (>> ?b ?c))" => {
            applier_rule_lshr_and_combine {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // ((a:i64>>c:i64)|(b:i64>>c:i64)) => ((a:i64|b:i64)>>c:i64)
        rewrite!("lshr_or_combine"; "(| (>> ?a ?c) (>> ?b ?c))" => {
            applier_rule_lshr_or_combine {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // ((a:i64>>c:i64)^(b:i64>>c:i64)) => ((a:i64^b:i64)>>c:i64)
        rewrite!("lshr_xor_combine"; "(^ (>> ?a ?c) (>> ?b ?c))" => {
            applier_rule_lshr_xor_combine {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64+b:i64) => (a:i64|b:i64)
        rewrite!("add_to_or"; "(+ ?a ?b)" => {
            applier_rule_add_to_or {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_add_to_or_precondition("?a", "?b"))),
        // ((t0:i64 ? c1:i64 : c2:i64)+v0:i64) => (t0:i64 ? (v0:i64+c1:i64) : (v0:i64+c2:i64))
        rewrite!("sink_select_add"; "(+ (select ?t0 ?c1 ?c2) ?v0)" => {
            applier_rule_sink_select_add {
                t0 : "?t0".parse().unwrap(),
                v0 : "?v0".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        }),
        // ((t0:i64 ? c1:i64 : c2:i64)*v0:i64) => (t0:i64 ? (v0:i64*c1:i64) : (v0:i64*c2:i64))
        rewrite!("sink_select_mul"; "(* (select ?t0 ?c1 ?c2) ?v0)" => {
            applier_rule_sink_select_mul {
                t0 : "?t0".parse().unwrap(),
                v0 : "?v0".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        }),
        // ((t0:i64 ? c1:i64 : c2:i64)&v0:i64) => (t0:i64 ? (v0:i64&c1:i64) : (v0:i64&c2:i64))
        rewrite!("sink_select_and"; "(& (select ?t0 ?c1 ?c2) ?v0)" => {
            applier_rule_sink_select_and {
                t0 : "?t0".parse().unwrap(),
                v0 : "?v0".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        }),
        // ((t0:i64 ? c1:i64 : c2:i64)|v0:i64) => (t0:i64 ? (v0:i64|c1:i64) : (v0:i64|c2:i64))
        rewrite!("sink_select_or"; "(| (select ?t0 ?c1 ?c2) ?v0)" => {
            applier_rule_sink_select_or {
                t0 : "?t0".parse().unwrap(),
                v0 : "?v0".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        }),
        // ((t0:i64 ? c1:i64 : c2:i64)^v0:i64) => (t0:i64 ? (v0:i64^c1:i64) : (v0:i64^c2:i64))
        rewrite!("sink_select_xor"; "(^ (select ?t0 ?c1 ?c2) ?v0)" => {
            applier_rule_sink_select_xor {
                t0 : "?t0".parse().unwrap(),
                v0 : "?v0".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        }),
        // (((a:i64&c1:i64)==mconst0:i64)|((b:i64&c2:i64)==mconst0:i64)) => (((a:i64&c1:i64)|(b:i64&c2:i64))<(c1:i64+c2:i64))
        rewrite!("eq_to_ugt"; "(| (\"icmp ==\" (& ?a ?c1) ?mconst0) (\"icmp ==\" (& ?b ?c2) ?mconst0))" => {
            applier_rule_eq_to_ugt {
                a : "?a".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_eq_to_ugt_precondition("?c1", "?c2", "?mconst0"))),
        // ((a:i64!=mconst0:i64)|(b:i64!=mconst0:i64)) => ((a:i64|b:i64)!=0:i64)
        rewrite!("factor_or_neg"; "(| (\"icmp !=\" ?a ?mconst0) (\"icmp !=\" ?b ?mconst0))" => {
            applier_rule_factor_or_neg {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_factor_or_neg_precondition("?mconst0"))),
        // ((a:i64 zx i64)&(b:i64 zx i64)) => ((a:i64&b:i64) zx i64)
        rewrite!("factor_zx_and"; "(& (zx ?a ?width) (zx ?b ?width))" => {
            applier_rule_factor_zx_and {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                width : "?width".parse().unwrap(),
            }
        }),
        // ((a:i64 tr i64)&(b:i64 tr i64)) => ((a:i64&b:i64) tr i64)
        rewrite!("factor_tr_and"; "(& (tr ?a ?width) (tr ?b ?width))" => {
            applier_rule_factor_tr_and {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                width : "?width".parse().unwrap(),
            }
        }),
        // ((a:i64 zx i64)|(b:i64 zx i64)) => ((a:i64|b:i64) zx i64)
        rewrite!("factor_zx_or"; "(| (zx ?a ?width) (zx ?b ?width))" => {
            applier_rule_factor_zx_or {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                width : "?width".parse().unwrap(),
            }
        }),
        // ((a:i64 tr i64)|(b:i64 tr i64)) => ((a:i64|b:i64) tr i64)
        rewrite!("factor_tr_or"; "(| (tr ?a ?width) (tr ?b ?width))" => {
            applier_rule_factor_tr_or {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                width : "?width".parse().unwrap(),
            }
        }),
        // ((a:i64 zx i64)^(b:i64 zx i64)) => ((a:i64^b:i64) zx i64)
        rewrite!("factor_zx_xor"; "(^ (zx ?a ?width) (zx ?b ?width))" => {
            applier_rule_factor_zx_xor {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                width : "?width".parse().unwrap(),
            }
        }),
        // ((a:i64 tr i64)^(b:i64 tr i64)) => ((a:i64^b:i64) tr i64)
        rewrite!("factor_tr_xor"; "(^ (tr ?a ?width) (tr ?b ?width))" => {
            applier_rule_factor_tr_xor {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                width : "?width".parse().unwrap(),
            }
        }),
        // ((a:i64*b:i64)+(a:i64*c:i64)) => (a:i64*(b:i64+c:i64))
        rewrite!("factor_mul"; "(+ (* ?a ?b) (* ?a ?c))" => {
            applier_rule_factor_mul {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // ((c1:i64*a:i64)+(c2:i64*a:i64)) => ((c1:i64+c2:i64)*a:i64)
        rewrite!("group_like_terms"; "(+ (* ?c1 ?a) (* ?c2 ?a))" => {
            applier_rule_group_like_terms {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_group_like_terms_precondition("?c1", "?c2"))),
        // a:i64 => (1:i64*a:i64)
        rewrite!("mul_identify"; "?a" => {
            applier_rule_mul_identify {
                a : "?a".parse().unwrap(),
            }
        }),
        // (x:i64&(~y:i64)) => (x:i64+((x:i64&y:i64)*-1:i64))
        rewrite!("neg_expand"; "(& ?x (~ ?y))" => {
            applier_rule_neg_expand {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // (a:i64|b:i64) => ((a:i64+b:i64)+((a:i64&b:i64)*-1:i64))
        rewrite!("or_expand"; "(| ?a ?b)" => {
            applier_rule_or_expand {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (a:i64^b:i64) => ((a:i64+b:i64)+((2:i64*(a:i64&b:i64))*-1:i64))
        rewrite!("xor_expand"; "(^ ?a ?b)" => {
            applier_rule_xor_expand {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (c1:i64^(x:i64&c1:i64)) => ((~x:i64)&c1:i64)
        rewrite!("xor_fold"; "(^ ?c1 (& ?x ?c1))" => {
            applier_rule_xor_fold {
                x : "?x".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
            }
        }),
        // (x:i64 tr i64) => ((x:i64&1:i64)==1:i64)
        rewrite!("tr_to_cmp"; "(tr ?x ?mconst0)" => {
            applier_rule_tr_to_cmp {
                x : "?x".parse().unwrap(),
            }
        } if (rule_tr_to_cmp_precondition("?mconst0"))),
        // ((x:i64==c1:i64)&(y:i64==c2:i64)) => ((x:i64|y:i64)==(c1:i64|c2:i64))
        rewrite!("merge_cmp"; "(& (\"icmp ==\" ?x ?c1) (\"icmp ==\" ?y ?c2))" => {
            applier_rule_merge_cmp {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_merge_cmp_precondition("?c1", "?c2", "?x", "?y"))),
        // (((x:i64&c1:i64)==mconst0:i64)&((y:i64&c2:i64)!=mconst0:i64)) => (((x:i64&c1:i64)|(y:i64&c2:i64))==c2:i64)
        rewrite!("merge_cmp_2"; "(& (\"icmp ==\" (& ?x ?c1) ?mconst0) (\"icmp !=\" (& ?y ?c2) ?mconst0))" => {
            applier_rule_merge_cmp_2 {
                x : "?x".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
                y : "?y".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_merge_cmp_2_precondition("?c1", "?c2", "?mconst0"))),
        // (a:i64==b:i64) => ((a:i64+(b:i64*-1:i64))==0:i64)
        rewrite!("eq_to_sub"; "(\"icmp ==\" ?a ?b)" => {
            applier_rule_eq_to_sub {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (a:i64==b:i64) => ((a:i64^b:i64)==0:i64)
        rewrite!("eq_to_xor"; "(\"icmp ==\" ?a ?b)" => {
            applier_rule_eq_to_xor {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (a:i64!=b:i64) => ((a:i64+(b:i64*-1:i64))!=0:i64)
        rewrite!("neq_to_sub"; "(\"icmp !=\" ?a ?b)" => {
            applier_rule_neq_to_sub {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (a:i64!=b:i64) => ((a:i64^b:i64)!=0:i64)
        rewrite!("neq_to_xor"; "(\"icmp !=\" ?a ?b)" => {
            applier_rule_neq_to_xor {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (mconst0:i1^(a:i64!=b:i64)) => (a:i64==b:i64)
        rewrite!("xor_ne"; "(^ ?mconst0 (\"icmp !=\" ?a ?b))" => {
            applier_rule_xor_ne {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_xor_ne_precondition("?mconst0"))),
        // (a:i64*c1:i64) => (c1:i64*a:i64)
        rewrite!("mul_constant_to_left_1"; "(* ?a ?c1)" => {
            applier_rule_mul_constant_to_left_1 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_mul_constant_to_left_1_precondition("?c1"))),
        // ((c1:i64*a:i64)*b:i64) => (c1:i64*(a:i64*b:i64))
        rewrite!("mul_constant_to_left_2"; "(* (* ?c1 ?a) ?b)" => {
            applier_rule_mul_constant_to_left_2 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_mul_constant_to_left_2_precondition("?c1"))),
        // (c1:i64*(c2:i64*a:i64)) => ((c1:i64*c2:i64)*a:i64)
        rewrite!("mul_constant_to_left_3"; "(* ?c1 (* ?c2 ?a))" => {
            applier_rule_mul_constant_to_left_3 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_mul_constant_to_left_3_precondition("?c1", "?c2"))),
        // (c1:i64*c2:i64) => (c1:i64*c2:i64)
        rewrite!("mul_constant_to_left_4"; "(* ?c1 ?c2)" => {
            applier_rule_mul_constant_to_left_4 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_mul_constant_to_left_4_precondition("?c1", "?c2"))),
        // (a:i64+c1:i64) => (c1:i64+a:i64)
        rewrite!("add_constant_to_left_1"; "(+ ?a ?c1)" => {
            applier_rule_add_constant_to_left_1 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_add_constant_to_left_1_precondition("?c1"))),
        // ((c1:i64+a:i64)+b:i64) => (c1:i64+(a:i64+b:i64))
        rewrite!("add_constant_to_left_2"; "(+ (+ ?c1 ?a) ?b)" => {
            applier_rule_add_constant_to_left_2 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_add_constant_to_left_2_precondition("?c1"))),
        // (c1:i64+(c2:i64+a:i64)) => ((c1:i64+c2:i64)+a:i64)
        rewrite!("add_constant_to_left_3"; "(+ ?c1 (+ ?c2 ?a))" => {
            applier_rule_add_constant_to_left_3 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_add_constant_to_left_3_precondition("?c1", "?c2"))),
        // (c1:i64+c2:i64) => (c1:i64+c2:i64)
        rewrite!("add_constant_to_left_4"; "(+ ?c1 ?c2)" => {
            applier_rule_add_constant_to_left_4 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_add_constant_to_left_4_precondition("?c1", "?c2"))),
        // (a:i64&c1:i64) => (c1:i64&a:i64)
        rewrite!("and_constant_to_left_1"; "(& ?a ?c1)" => {
            applier_rule_and_constant_to_left_1 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_and_constant_to_left_1_precondition("?c1"))),
        // ((c1:i64&a:i64)&b:i64) => (c1:i64&(a:i64&b:i64))
        rewrite!("and_constant_to_left_2"; "(& (& ?c1 ?a) ?b)" => {
            applier_rule_and_constant_to_left_2 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_and_constant_to_left_2_precondition("?c1"))),
        // (c1:i64&(c2:i64&a:i64)) => ((c1:i64&c2:i64)&a:i64)
        rewrite!("and_constant_to_left_3"; "(& ?c1 (& ?c2 ?a))" => {
            applier_rule_and_constant_to_left_3 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_and_constant_to_left_3_precondition("?c1", "?c2"))),
        // (c1:i64&c2:i64) => (c1:i64&c2:i64)
        rewrite!("and_constant_to_left_4"; "(& ?c1 ?c2)" => {
            applier_rule_and_constant_to_left_4 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_and_constant_to_left_4_precondition("?c1", "?c2"))),
        // (a:i64|c1:i64) => (c1:i64|a:i64)
        rewrite!("or_constant_to_left_1"; "(| ?a ?c1)" => {
            applier_rule_or_constant_to_left_1 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_or_constant_to_left_1_precondition("?c1"))),
        // ((c1:i64|a:i64)|b:i64) => (c1:i64|(a:i64|b:i64))
        rewrite!("or_constant_to_left_2"; "(| (| ?c1 ?a) ?b)" => {
            applier_rule_or_constant_to_left_2 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_or_constant_to_left_2_precondition("?c1"))),
        // (c1:i64|(c2:i64|a:i64)) => ((c1:i64|c2:i64)|a:i64)
        rewrite!("or_constant_to_left_3"; "(| ?c1 (| ?c2 ?a))" => {
            applier_rule_or_constant_to_left_3 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_or_constant_to_left_3_precondition("?c1", "?c2"))),
        // (c1:i64|c2:i64) => (c1:i64|c2:i64)
        rewrite!("or_constant_to_left_4"; "(| ?c1 ?c2)" => {
            applier_rule_or_constant_to_left_4 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_or_constant_to_left_4_precondition("?c1", "?c2"))),
        // (a:i64^c1:i64) => (c1:i64^a:i64)
        rewrite!("xor_constant_to_left_1"; "(^ ?a ?c1)" => {
            applier_rule_xor_constant_to_left_1 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_xor_constant_to_left_1_precondition("?c1"))),
        // ((c1:i64^a:i64)^b:i64) => (c1:i64^(a:i64^b:i64))
        rewrite!("xor_constant_to_left_2"; "(^ (^ ?c1 ?a) ?b)" => {
            applier_rule_xor_constant_to_left_2 {
                c1 : "?c1".parse().unwrap(),
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_xor_constant_to_left_2_precondition("?c1"))),
        // (c1:i64^(c2:i64^a:i64)) => ((c1:i64^c2:i64)^a:i64)
        rewrite!("xor_constant_to_left_3"; "(^ ?c1 (^ ?c2 ?a))" => {
            applier_rule_xor_constant_to_left_3 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        } if (rule_xor_constant_to_left_3_precondition("?c1", "?c2"))),
        // (c1:i64^c2:i64) => (c1:i64^c2:i64)
        rewrite!("xor_constant_to_left_4"; "(^ ?c1 ?c2)" => {
            applier_rule_xor_constant_to_left_4 {
                c1 : "?c1".parse().unwrap(),
                c2 : "?c2".parse().unwrap(),
            }
        } if (rule_xor_constant_to_left_4_precondition("?c1", "?c2"))),
        // (~c1:i64) => (~c1:i64)
        rewrite!("neg_constant_to_left_1"; "(~ ?c1)" => {
            applier_rule_neg_constant_to_left_1 {
                c1 : "?c1".parse().unwrap(),
            }
        } if (rule_neg_constant_to_left_1_precondition("?c1"))),
        // (mconst0:i64+(mconst0:i64*a:i64)) => (~a:i64)
        rewrite!("arith_to_negation"; "(+ ?mconst0 (* ?mconst0 ?a))" => {
            applier_rule_arith_to_negation {
                a : "?a".parse().unwrap(),
            }
        } if (rule_arith_to_negation_precondition("?mconst0"))),
        // (mconst0:i64+(~a:i64)) => (-1:i64*a:i64)
        rewrite!("add_negate_to_invert_sign"; "(+ ?mconst0 (~ ?a))" => {
            applier_rule_add_negate_to_invert_sign {
                a : "?a".parse().unwrap(),
            }
        } if (rule_add_negate_to_invert_sign_precondition("?mconst0"))),
        // (((a:i64&d:i64)*(a:i64|d:i64))+((a:i64&(~d:i64))*((~a:i64)&d:i64))) => (a:i64*d:i64)
        rewrite!("head_scratcher"; "(+ (* (& ?a ?d) (| ?a ?d)) (* (& ?a (~ ?d)) (& (~ ?a) ?d)))" => {
            applier_rule_head_scratcher {
                a : "?a".parse().unwrap(),
                d : "?d".parse().unwrap(),
            }
        }),
        // ((x:i64|y:i64)+(x:i64&y:i64)) => (x:i64+y:i64)
        rewrite!("or_and_to_add"; "(+ (| ?x ?y) (& ?x ?y))" => {
            applier_rule_or_and_to_add {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // ((mconst0:i64*(a:i64&(~d:i64)))+(mconst1:i64*(a:i64^d:i64))) => (a:i64+(-1:i64*d:i64))
        rewrite!("qsynth_1"; "(+ (* ?mconst0 (& ?a (~ ?d))) (* ?mconst1 (^ ?a ?d)))" => {
            applier_rule_qsynth_1 {
                a : "?a".parse().unwrap(),
                d : "?d".parse().unwrap(),
            }
        } if (rule_qsynth_1_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*(d:i64&v1:i64))+(d:i64^v1:i64)) => (d:i64+v1:i64)
        rewrite!("qsynth_2"; "(+ (* ?mconst0 (& ?d ?v1)) (^ ?d ?v1))" => {
            applier_rule_qsynth_2 {
                d : "?d".parse().unwrap(),
                v1 : "?v1".parse().unwrap(),
            }
        } if (rule_qsynth_2_precondition("?mconst0"))),
        // ((d:i64^v1:i64)+(mconst0:i64*(d:i64&v1:i64))) => (d:i64+v1:i64)
        rewrite!("qsynth_2_commutative"; "(+ (^ ?d ?v1) (* ?mconst0 (& ?d ?v1)))" => {
            applier_rule_qsynth_2_commutative {
                d : "?d".parse().unwrap(),
                v1 : "?v1".parse().unwrap(),
            }
        } if (rule_qsynth_2_commutative_precondition("?mconst0"))),
        // (mconst0:i64|a:i64) => a:i64
        rewrite!("or_zero"; "(| ?mconst0 ?a)" => {
            applier_rule_or_zero {
                a : "?a".parse().unwrap(),
            }
        } if (rule_or_zero_precondition("?mconst0"))),
        // (mconst0:i64|a:i64) => -1:i64
        rewrite!("or_maxint"; "(| ?mconst0 ?a)" => {
            applier_rule_or_maxint {
                a : "?a".parse().unwrap(),
            }
        } if (rule_or_maxint_precondition("?mconst0"))),
        // (a:i64|a:i64) => a:i64
        rewrite!("or_itself"; "(| ?a ?a)" => {
            applier_rule_or_itself {
                a : "?a".parse().unwrap(),
            }
        }),
        // (a:i64|(~a:i64)) => -1:i64
        rewrite!("or_negated_itself"; "(| ?a (~ ?a))" => {
            applier_rule_or_negated_itself {
                a : "?a".parse().unwrap(),
            }
        }),
        // (mconst0:i64^a:i64) => a:i64
        rewrite!("xor_zero"; "(^ ?mconst0 ?a)" => {
            applier_rule_xor_zero {
                a : "?a".parse().unwrap(),
            }
        } if (rule_xor_zero_precondition("?mconst0"))),
        // (mconst0:i64^a:i64) => (~a:i64)
        rewrite!("xor_maxint"; "(^ ?mconst0 ?a)" => {
            applier_rule_xor_maxint {
                a : "?a".parse().unwrap(),
            }
        } if (rule_xor_maxint_precondition("?mconst0"))),
        // (a:i64^a:i64) => 0:i64
        rewrite!("xor_itself"; "(^ ?a ?a)" => {
            applier_rule_xor_itself {
                a : "?a".parse().unwrap(),
            }
        }),
        // (((~a:i64)&b:i64)|(a:i64&(~b:i64))) => (a:i64^b:i64)
        rewrite!("xor_reduce"; "(| (& (~ ?a) ?b) (& ?a (~ ?b)))" => {
            applier_rule_xor_reduce {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (mconst0:i64&a:i64) => 0:i64
        rewrite!("and_zero"; "(& ?mconst0 ?a)" => {
            applier_rule_and_zero {
                a : "?a".parse().unwrap(),
            }
        } if (rule_and_zero_precondition("?mconst0"))),
        // (mconst0:i64&a:i64) => a:i64
        rewrite!("and_maxint"; "(& ?mconst0 ?a)" => {
            applier_rule_and_maxint {
                a : "?a".parse().unwrap(),
            }
        } if (rule_and_maxint_precondition("?mconst0"))),
        // (a:i64&a:i64) => a:i64
        rewrite!("and_itself"; "(& ?a ?a)" => {
            applier_rule_and_itself {
                a : "?a".parse().unwrap(),
            }
        }),
        // (a:i64&(~a:i64)) => 0:i64
        rewrite!("and_negated_itself"; "(& ?a (~ ?a))" => {
            applier_rule_and_negated_itself {
                a : "?a".parse().unwrap(),
            }
        }),
        // (a:i64+a:i64) => (2:i64*a:i64)
        rewrite!("add_itself"; "(+ ?a ?a)" => {
            applier_rule_add_itself {
                a : "?a".parse().unwrap(),
            }
        }),
        // (mconst0:i64+a:i64) => a:i64
        rewrite!("add_zero"; "(+ ?mconst0 ?a)" => {
            applier_rule_add_zero {
                a : "?a".parse().unwrap(),
            }
        } if (rule_add_zero_precondition("?mconst0"))),
        // (a:i64+(mconst0:i64*a:i64)) => 0:i64
        rewrite!("add_cancellation"; "(+ ?a (* ?mconst0 ?a))" => {
            applier_rule_add_cancellation {
                a : "?a".parse().unwrap(),
            }
        } if (rule_add_cancellation_precondition("?mconst0"))),
        // (mconst0:i64*a:i64) => 0:i64
        rewrite!("mul_zero"; "(* ?mconst0 ?a)" => {
            applier_rule_mul_zero {
                a : "?a".parse().unwrap(),
            }
        } if (rule_mul_zero_precondition("?mconst0"))),
        // (mconst0:i64*a:i64) => a:i64
        rewrite!("mul_one"; "(* ?mconst0 ?a)" => {
            applier_rule_mul_one {
                a : "?a".parse().unwrap(),
            }
        } if (rule_mul_one_precondition("?mconst0"))),
        // (a:i64**mconst0:i64) => 1:i64
        rewrite!("power_zero"; "(** ?a ?mconst0)" => {
            applier_rule_power_zero {
                a : "?a".parse().unwrap(),
            }
        } if (rule_power_zero_precondition("?mconst0"))),
        // (a:i64**mconst0:i64) => a:i64
        rewrite!("power_one"; "(** ?a ?mconst0)" => {
            applier_rule_power_one {
                a : "?a".parse().unwrap(),
            }
        } if (rule_power_one_precondition("?mconst0"))),
        // (mconst0:i64*(mconst0:i64*a:i64)) => a:i64
        rewrite!("minus_twice"; "(* ?mconst0 (* ?mconst0 ?a))" => {
            applier_rule_minus_twice {
                a : "?a".parse().unwrap(),
            }
        } if (rule_minus_twice_precondition("?mconst0"))),
        // (~(~a:i64)) => a:i64
        rewrite!("negate_twice"; "(~ (~ ?a))" => {
            applier_rule_negate_twice {
                a : "?a".parse().unwrap(),
            }
        }),
        // ((mconst0:i64+(mconst0:i64*a:i64))&b:i64) => ((~a:i64)&b:i64)
        rewrite!("and_bitwise_negation"; "(& (+ ?mconst0 (* ?mconst0 ?a)) ?b)" => {
            applier_rule_and_bitwise_negation {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_and_bitwise_negation_precondition("?mconst0"))),
        // ((mconst0:i64+(mconst0:i64*a:i64))|b:i64) => ((~a:i64)|b:i64)
        rewrite!("or_bitwise_negation"; "(| (+ ?mconst0 (* ?mconst0 ?a)) ?b)" => {
            applier_rule_or_bitwise_negation {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_or_bitwise_negation_precondition("?mconst0"))),
        // ((mconst0:i64+(mconst0:i64*a:i64))^b:i64) => ((~a:i64)^b:i64)
        rewrite!("xor_bitwise_negation"; "(^ (+ ?mconst0 (* ?mconst0 ?a)) ?b)" => {
            applier_rule_xor_bitwise_negation {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_xor_bitwise_negation_precondition("?mconst0"))),
        // ((x:i64&y:i64)+((~x:i64)&y:i64)) => y:i64
        rewrite!("__merge_inverse_bitwise_terms_19"; "(+ (& ?x ?y) (& (~ ?x) ?y))" => {
            applier_rule___merge_inverse_bitwise_terms_19 {
                y : "?y".parse().unwrap(),
            }
        }),
        // ((x:i64|y:i64)+((~x:i64)|y:i64)) => (-1:i64+y:i64)
        rewrite!("__merge_inverse_bitwise_terms_20"; "(+ (| ?x ?y) (| (~ ?x) ?y))" => {
            applier_rule___merge_inverse_bitwise_terms_20 {
                y : "?y".parse().unwrap(),
            }
        }),
        // ((x:i64^y:i64)+((~x:i64)^y:i64)) => -1:i64
        rewrite!("__merge_inverse_bitwise_terms_21"; "(+ (^ ?x ?y) (^ (~ ?x) ?y))" => {
            applier_rule___merge_inverse_bitwise_terms_21 {
                x : "?x".parse().unwrap(),
            }
        }),
        // ((x:i64|y:i64)+(mconst0:i64*((~x:i64)&y:i64))) => x:i64
        rewrite!("__merge_inverse_bitwise_terms_22"; "(+ (| ?x ?y) (* ?mconst0 (& (~ ?x) ?y)))" => {
            applier_rule___merge_inverse_bitwise_terms_22 {
                x : "?x".parse().unwrap(),
            }
        } if (rule___merge_inverse_bitwise_terms_22_precondition("?mconst0"))),
        // ((x:i64^y:i64)+(mconst0:i64*(mconst1:i64*((~x:i64)&y:i64)))) => (x:i64+(-1:i64*y:i64))
        rewrite!("__merge_inverse_bitwise_terms_23"; "(+ (^ ?x ?y) (* ?mconst0 (* ?mconst1 (& (~ ?x) ?y))))" => {
            applier_rule___merge_inverse_bitwise_terms_23 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule___merge_inverse_bitwise_terms_23_precondition("?mconst0", "?mconst1"))),
        // ((x:i64^y:i64)+(mconst0:i64*((~x:i64)|y:i64))) => ((-2:i64+(-1:i64*x:i64))+y:i64)
        rewrite!("__merge_inverse_bitwise_terms_24"; "(+ (^ ?x ?y) (* ?mconst0 (| (~ ?x) ?y)))" => {
            applier_rule___merge_inverse_bitwise_terms_24 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule___merge_inverse_bitwise_terms_24_precondition("?mconst0"))),
        // (~((~a:i64)&b:i64)) => (a:i64|(~b:i64))
        rewrite!("and_move_bitwise_negation_in"; "(~ (& (~ ?a) ?b))" => {
            applier_rule_and_move_bitwise_negation_in {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (~((~a:i64)|b:i64)) => (a:i64&(~b:i64))
        rewrite!("or_move_bitwise_negation_in"; "(~ (| (~ ?a) ?b))" => {
            applier_rule_or_move_bitwise_negation_in {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (~((~a:i64)^b:i64)) => (a:i64^b:i64)
        rewrite!("xor_move_bitwise_negation_in"; "(~ (^ (~ ?a) ?b))" => {
            applier_rule_xor_move_bitwise_negation_in {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // ((a:i64**b:i64)*(a:i64**c:i64)) => (a:i64**(b:i64+c:i64))
        rewrite!("merge_power_same_base"; "(* (** ?a ?b) (** ?a ?c))" => {
            applier_rule_merge_power_same_base {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (a:i64+(~a:i64)) => -1:i64
        rewrite!("invert_add_bitwise_not_self"; "(+ ?a (~ ?a))" => {
            applier_rule_invert_add_bitwise_not_self {
                a : "?a".parse().unwrap(),
            }
        }),
        // ((a:i64*(~b:i64))+(a:i64*b:i64)) => (-1:i64*a:i64)
        rewrite!("invert_mul_bitwise_not_self"; "(+ (* ?a (~ ?b)) (* ?a ?b))" => {
            applier_rule_invert_mul_bitwise_not_self {
                a : "?a".parse().unwrap(),
            }
        }),
        // (y:i64&(~(y:i64|x:i64))) => 0:i64
        rewrite!("asddsasad"; "(& ?y (~ (| ?y ?x)))" => {
            applier_rule_asddsasad {
                x : "?x".parse().unwrap(),
            }
        }),
        // (mconst0:i64*(a:i64|(mconst1:i64*a:i64))) => (a:i64^(-1:i64*a:i64))
        rewrite!("xor_same_mult_by_minus_one_1"; "(* ?mconst0 (| ?a (* ?mconst1 ?a)))" => {
            applier_rule_xor_same_mult_by_minus_one_1 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_xor_same_mult_by_minus_one_1_precondition("?mconst0", "?mconst1"))),
        // (mconst0:i64*(a:i64&(mconst1:i64*a:i64))) => (a:i64^(-1:i64*a:i64))
        rewrite!("xor_same_mult_by_minus_one_2"; "(* ?mconst0 (& ?a (* ?mconst1 ?a)))" => {
            applier_rule_xor_same_mult_by_minus_one_2 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_xor_same_mult_by_minus_one_2_precondition("?mconst0", "?mconst1"))),
        // (a:i64&((mconst0:i64*a:i64)&(mconst1:i64*a:i64))) => 0:i64
        rewrite!("conj_zero_rule"; "(& ?a (& (* ?mconst0 ?a) (* ?mconst1 ?a)))" => {
            applier_rule_conj_zero_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_zero_rule_precondition("?mconst0", "?mconst1"))),
        // ((~(mconst0:i64*a:i64))&(mconst1:i64*(a:i64^(mconst1:i64*a:i64)))) => 0:i64
        rewrite!("conj_neg_xor_zero_rule"; "(& (~ (* ?mconst0 ?a)) (* ?mconst1 (^ ?a (* ?mconst1 ?a))))" => {
            applier_rule_conj_neg_xor_zero_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_neg_xor_zero_rule_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)|(~(mconst1:i64*(a:i64^(mconst1:i64*a:i64))))) => -1:i64
        rewrite!("conj_neg_xor_minus_one_rule"; "(| (* ?mconst0 ?a) (~ (* ?mconst1 (^ ?a (* ?mconst1 ?a)))))" => {
            applier_rule_conj_neg_xor_minus_one_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_neg_xor_minus_one_rule_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)&(~(a:i64^(mconst1:i64*a:i64)))) => 0:i64
        rewrite!("conj_negated_xor_zero_rule"; "(& (* ?mconst0 ?a) (~ (^ ?a (* ?mconst1 ?a))))" => {
            applier_rule_conj_negated_xor_zero_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_negated_xor_zero_rule_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)&(a:i64^(mconst1:i64*a:i64))) => (2:i64*a:i64)
        rewrite!("conj_xor_identity_rule"; "(& (* ?mconst0 ?a) (^ ?a (* ?mconst1 ?a)))" => {
            applier_rule_conj_xor_identity_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_xor_identity_rule_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)|(mconst1:i64*(a:i64^(mconst1:i64*a:i64)))) => (2:i64*a:i64)
        rewrite!("disj_xor_identity_rule"; "(| (* ?mconst0 ?a) (* ?mconst1 (^ ?a (* ?mconst1 ?a))))" => {
            applier_rule_disj_xor_identity_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_disj_xor_identity_rule_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)&(~(a:i64&(mconst1:i64*a:i64)))) => (-1:i64*a:i64)
        rewrite!("conj_neg_conj_identity_rule_1"; "(& (* ?mconst0 ?a) (~ (& ?a (* ?mconst1 ?a))))" => {
            applier_rule_conj_neg_conj_identity_rule_1 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_neg_conj_identity_rule_1_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)&(~(a:i64&(mconst1:i64*a:i64)))) => (-1:i64*a:i64)
        rewrite!("conj_neg_conj_identity_rule_2"; "(& (* ?mconst0 ?a) (~ (& ?a (* ?mconst1 ?a))))" => {
            applier_rule_conj_neg_conj_identity_rule_2 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_neg_conj_identity_rule_2_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)&((~a:i64)|(~(mconst1:i64*a:i64)))) => (-1:i64*a:i64)
        rewrite!("conj_neg_conj_identity_rule_3"; "(& (* ?mconst0 ?a) (| (~ ?a) (~ (* ?mconst1 ?a))))" => {
            applier_rule_conj_neg_conj_identity_rule_3 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_neg_conj_identity_rule_3_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)&((~a:i64)|(~(mconst1:i64*a:i64)))) => (-1:i64*a:i64)
        rewrite!("conj_neg_conj_identity_rule_4"; "(& (* ?mconst0 ?a) (| (~ ?a) (~ (* ?mconst1 ?a))))" => {
            applier_rule_conj_neg_conj_identity_rule_4 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_neg_conj_identity_rule_4_precondition("?mconst0", "?mconst1"))),
        // (a:i64|(mconst0:i64*(a:i64|(mconst0:i64*a:i64)))) => a:i64
        rewrite!("disj_disj_identity_rule"; "(| ?a (* ?mconst0 (| ?a (* ?mconst0 ?a))))" => {
            applier_rule_disj_disj_identity_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_disj_disj_identity_rule_precondition("?mconst0"))),
        // (a:i64&(mconst0:i64*(a:i64&(mconst0:i64*a:i64)))) => a:i64
        rewrite!("conj_conj_identity_rule"; "(& ?a (* ?mconst0 (& ?a (* ?mconst0 ?a))))" => {
            applier_rule_conj_conj_identity_rule {
                a : "?a".parse().unwrap(),
            }
        } if (rule_conj_conj_identity_rule_precondition("?mconst0"))),
        // ((mconst0:i64*a:i64)|((~a:i64)&(mconst1:i64*a:i64))) => (-1:i64*a:i64)
        rewrite!("disj_conj_identity_rule_1"; "(| (* ?mconst0 ?a) (& (~ ?a) (* ?mconst1 ?a)))" => {
            applier_rule_disj_conj_identity_rule_1 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_disj_conj_identity_rule_1_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)|((~a:i64)&(mconst1:i64*a:i64))) => (-1:i64*a:i64)
        rewrite!("disj_conj_identity_rule_2"; "(| (* ?mconst0 ?a) (& (~ ?a) (* ?mconst1 ?a)))" => {
            applier_rule_disj_conj_identity_rule_2 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_disj_conj_identity_rule_2_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)|(~(a:i64|(~(mconst1:i64*a:i64))))) => (-1:i64*a:i64)
        rewrite!("disj_conj_identity_rule_3"; "(| (* ?mconst0 ?a) (~ (| ?a (~ (* ?mconst1 ?a)))))" => {
            applier_rule_disj_conj_identity_rule_3 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_disj_conj_identity_rule_3_precondition("?mconst0", "?mconst1"))),
        // ((mconst0:i64*a:i64)|(~(a:i64|(~(mconst1:i64*a:i64))))) => (-1:i64*a:i64)
        rewrite!("disj_conj_identity_rule_4"; "(| (* ?mconst0 ?a) (~ (| ?a (~ (* ?mconst1 ?a)))))" => {
            applier_rule_disj_conj_identity_rule_4 {
                a : "?a".parse().unwrap(),
            }
        } if (rule_disj_conj_identity_rule_4_precondition("?mconst0", "?mconst1"))),
        // (x:i64|((mconst0:i64*(~x:i64))&(mconst1:i64*(~x:i64)))) => x:i64
        rewrite!("disj_conj_identity_rule_2_1"; "(| ?x (& (* ?mconst0 (~ ?x)) (* ?mconst1 (~ ?x))))" => {
            applier_rule_disj_conj_identity_rule_2_1 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_disj_conj_identity_rule_2_1_precondition("?mconst0", "?mconst1"))),
        // (x:i64|((mconst0:i64*(~x:i64))&((mconst0:i64*mconst1:i64)*(~x:i64)))) => x:i64
        rewrite!("disj_conj_identity_rule_2_2"; "(| ?x (& (* ?mconst0 (~ ?x)) (* (* ?mconst0 ?mconst1) (~ ?x))))" => {
            applier_rule_disj_conj_identity_rule_2_2 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_disj_conj_identity_rule_2_2_precondition("?mconst0", "?mconst1"))),
        // (x:i64&((mconst0:i64*(~(mconst1:i64*x:i64)))|(mconst0:i64*(~x:i64)))) => x:i64
        rewrite!("conj_disj_identity_rule_1"; "(& ?x (| (* ?mconst0 (~ (* ?mconst1 ?x))) (* ?mconst0 (~ ?x))))" => {
            applier_rule_conj_disj_identity_rule_1 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_conj_disj_identity_rule_1_precondition("?mconst0", "?mconst1"))),
        // (x:i64&((~(mconst0:i64*(~x:i64)))|(mconst1:i64*(~x:i64)))) => x:i64
        rewrite!("conj_disj_identity_rule_2"; "(& ?x (| (~ (* ?mconst0 (~ ?x))) (* ?mconst1 (~ ?x))))" => {
            applier_rule_conj_disj_identity_rule_2 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_conj_disj_identity_rule_2_precondition("?mconst0", "?mconst1"))),
        // (x:i64&((~((mconst0:i64*y:i64)*(~x:i64)))|(mconst0:i64*(~x:i64)))) => x:i64
        rewrite!("conj_disj_identity_rule_3"; "(& ?x (| (~ (* (* ?mconst0 ?y) (~ ?x))) (* ?mconst0 (~ ?x))))" => {
            applier_rule_conj_disj_identity_rule_3 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_conj_disj_identity_rule_3_precondition("?mconst0"))),
        // (x:i64|(mconst0:i64*((mconst0:i64*x:i64)|(y:i64*x:i64)))) => x:i64
        rewrite!("disj_neg_disj_identity_rule_1"; "(| ?x (* ?mconst0 (| (* ?mconst0 ?x) (* ?y ?x))))" => {
            applier_rule_disj_neg_disj_identity_rule_1 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_disj_neg_disj_identity_rule_1_precondition("?mconst0"))),
        // (x:i64|(mconst0:i64*((mconst0:i64*x:i64)|((mconst0:i64*y:i64)*x:i64)))) => x:i64
        rewrite!("disj_neg_disj_identity_rule_2"; "(| ?x (* ?mconst0 (| (* ?mconst0 ?x) (* (* ?mconst0 ?y) ?x))))" => {
            applier_rule_disj_neg_disj_identity_rule_2 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_disj_neg_disj_identity_rule_2_precondition("?mconst0"))),
        // (x:i64|((x:i64|y:i64)+(mconst0:i64*y:i64))) => x:i64
        rewrite!("disj_sub_disj_identity_rule_1"; "(| ?x (+ (| ?x ?y) (* ?mconst0 ?y)))" => {
            applier_rule_disj_sub_disj_identity_rule_1 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_disj_sub_disj_identity_rule_1_precondition("?mconst0"))),
        // (x:i64|(x:i64+(mconst0:i64*(x:i64&y:i64)))) => x:i64
        rewrite!("disj_sub_disj_identity_rule_2"; "(| ?x (+ ?x (* ?mconst0 (& ?x ?y))))" => {
            applier_rule_disj_sub_disj_identity_rule_2 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_disj_sub_disj_identity_rule_2_precondition("?mconst0"))),
        // (x:i64&(x:i64+((~x:i64)&y:i64))) => x:i64
        rewrite!("conj_add_conj_identity_rule"; "(& ?x (+ ?x (& (~ ?x) ?y)))" => {
            applier_rule_conj_add_conj_identity_rule {
                x : "?x".parse().unwrap(),
            }
        }),
        // (x:i64|(mconst0:i64*((mconst0:i64*y:i64)|(x:i64&y:i64)))) => (x:i64|y:i64)
        rewrite!("disj_disj_conj_rule"; "(| ?x (* ?mconst0 (| (* ?mconst0 ?y) (& ?x ?y))))" => {
            applier_rule_disj_disj_conj_rule {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_disj_disj_conj_rule_precondition("?mconst0"))),
        // (x:i64&(mconst0:i64*((mconst0:i64*y:i64)&(x:i64|y:i64)))) => (x:i64&y:i64)
        rewrite!("conj_conj_disj_rule"; "(& ?x (* ?mconst0 (& (* ?mconst0 ?y) (| ?x ?y))))" => {
            applier_rule_conj_conj_disj_rule {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_conj_conj_disj_rule_precondition("?mconst0"))),
        // ((mconst0:i64*((mconst0:i64*x:i64)|((x:i64&y:i64)&z:i64)))|(x:i64&y:i64)) => x:i64
        rewrite!("disj_disj_conj_rule_2"; "(| (* ?mconst0 (| (* ?mconst0 ?x) (& (& ?x ?y) ?z))) (& ?x ?y))" => {
            applier_rule_disj_disj_conj_rule_2 {
                x : "?x".parse().unwrap(),
            }
        } if (rule_disj_disj_conj_rule_2_precondition("?mconst0"))),
        // ((mconst0:i64*(x:i64|y:i64))+(mconst1:i64*x:i64)) => (y:i64+(x:i64^y:i64))
        rewrite!("__check_bitwise_in_sums_cancel_terms_4"; "(+ (* ?mconst0 (| ?x ?y)) (* ?mconst1 ?x))" => {
            applier_rule___check_bitwise_in_sums_cancel_terms_4 {
                y : "?y".parse().unwrap(),
                x : "?x".parse().unwrap(),
            }
        } if (rule___check_bitwise_in_sums_cancel_terms_4_precondition("?mconst0", "?mconst1"))),
        // ((x:i64&y:i64)|(x:i64^y:i64)) => ((x:i64&y:i64)+(x:i64^y:i64))
        rewrite!("__check_disj_involving_xor_in_sums_rule_1"; "(| (& ?x ?y) (^ ?x ?y))" => {
            applier_rule___check_disj_involving_xor_in_sums_rule_1 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // (((z:i64&x:i64)&y:i64)|(x:i64^y:i64)) => (((z:i64&x:i64)&y:i64)+(x:i64^y:i64))
        rewrite!("__check_disj_involving_xor_in_sums_rule_2"; "(| (& (& ?z ?x) ?y) (^ ?x ?y))" => {
            applier_rule___check_disj_involving_xor_in_sums_rule_2 {
                z : "?z".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // (x:i64^(x:i64|y:i64)) => ((~x:i64)&y:i64)
        rewrite!("__check_xor_involving_disj_rule"; "(^ ?x (| ?x ?y))" => {
            applier_rule___check_xor_involving_disj_rule {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // ((a:i64*a:i64)+(a:i64*(~a:i64))) => (-1:i64*a:i64)
        rewrite!("add_negated_itself_by_two"; "(+ (* ?a ?a) (* ?a (~ ?a)))" => {
            applier_rule_add_negated_itself_by_two {
                a : "?a".parse().unwrap(),
            }
        }),
        // (((c:i64*x:i64)+(c:i64*y:i64))+(mconst0:i64*(c:i64*(x:i64&y:i64)))) => (c:i64*(x:i64|y:i64))
        rewrite!("or_mul_shrink"; "(+ (+ (* ?c ?x) (* ?c ?y)) (* ?mconst0 (* ?c (& ?x ?y))))" => {
            applier_rule_or_mul_shrink {
                c : "?c".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_or_mul_shrink_precondition("?mconst0"))),
        // ((a:i64&b:i64)+(a:i64^b:i64)) => (a:i64|b:i64)
        rewrite!("or_shrink"; "(+ (& ?a ?b) (^ ?a ?b))" => {
            applier_rule_or_shrink {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (~((~a:i64)&(~b:i64))) => (b:i64|a:i64)
        rewrite!("or_shrink_2"; "(~ (& (~ ?a) (~ ?b)))" => {
            applier_rule_or_shrink_2 {
                b : "?b".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        }),
        // (x:i64+(y:i64&(~x:i64))) => (x:i64|y:i64)
        rewrite!("or_shrink_3"; "(+ ?x (& ?y (~ ?x)))" => {
            applier_rule_or_shrink_3 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // ((a:i64^b:i64)|a:i64) => (a:i64|b:i64)
        rewrite!("or_shrink_4"; "(| (^ ?a ?b) ?a)" => {
            applier_rule_or_shrink_4 {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (((c:i64*x:i64)+(c:i64*y:i64))+(mconst0:i64*((mconst1:i64*c:i64)*(x:i64&y:i64)))) => (c:i64*(x:i64^y:i64))
        rewrite!("xor_mul_shrink"; "(+ (+ (* ?c ?x) (* ?c ?y)) (* ?mconst0 (* (* ?mconst1 ?c) (& ?x ?y))))" => {
            applier_rule_xor_mul_shrink {
                c : "?c".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_xor_mul_shrink_precondition("?mconst0", "?mconst1"))),
        // ((x:i64+y:i64)+(mconst0:i64*(x:i64&y:i64))) => (x:i64^y:i64)
        rewrite!("xor_shrink"; "(+ (+ ?x ?y) (* ?mconst0 (& ?x ?y)))" => {
            applier_rule_xor_shrink {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_xor_shrink_precondition("?mconst0"))),
        // ((a:i64|b:i64)+(mconst0:i64*(a:i64&b:i64))) => (a:i64^b:i64)
        rewrite!("xor_shrink2"; "(+ (| ?a ?b) (* ?mconst0 (& ?a ?b)))" => {
            applier_rule_xor_shrink2 {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_xor_shrink2_precondition("?mconst0"))),
        // ((~((~a:i64)&(~b:i64)))&(~(a:i64&b:i64))) => (b:i64^a:i64)
        rewrite!("xor_shrink_3"; "(& (~ (& (~ ?a) (~ ?b))) (~ (& ?a ?b)))" => {
            applier_rule_xor_shrink_3 {
                b : "?b".parse().unwrap(),
                a : "?a".parse().unwrap(),
            }
        }),
        // ((x:i64&y:i64)+(~(x:i64|y:i64))) => (~(x:i64^y:i64))
        rewrite!("negated_xor_shrink_4"; "(+ (& ?x ?y) (~ (| ?x ?y)))" => {
            applier_rule_negated_xor_shrink_4 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // (((a:i64*b:i64)+(a:i64*c:i64))+(mconst0:i64*(a:i64*(b:i64|c:i64)))) => (a:i64*(b:i64&c:i64))
        rewrite!("and_mul_shrink"; "(+ (+ (* ?a ?b) (* ?a ?c)) (* ?mconst0 (* ?a (| ?b ?c))))" => {
            applier_rule_and_mul_shrink {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        } if (rule_and_mul_shrink_precondition("?mconst0"))),
        // ((a:i64|b:i64)+(mconst0:i64*(a:i64^b:i64))) => (a:i64&b:i64)
        rewrite!("and_shrink"; "(+ (| ?a ?b) (* ?mconst0 (^ ?a ?b)))" => {
            applier_rule_and_shrink {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_and_shrink_precondition("?mconst0"))),
        // ((a:i64&b:i64)+(a:i64|b:i64)) => (a:i64+b:i64)
        rewrite!("add_shrink"; "(+ (& ?a ?b) (| ?a ?b))" => {
            applier_rule_add_shrink {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // ((b:i64*a:i64)+(mconst0:i64*(b:i64*(a:i64&d:i64)))) => (b:i64*(a:i64&(~d:i64)))
        rewrite!("cancel_and_reduce_bitwise_subtraction"; "(+ (* ?b ?a) (* ?mconst0 (* ?b (& ?a ?d))))" => {
            applier_rule_cancel_and_reduce_bitwise_subtraction {
                b : "?b".parse().unwrap(),
                a : "?a".parse().unwrap(),
                d : "?d".parse().unwrap(),
            }
        } if (rule_cancel_and_reduce_bitwise_subtraction_precondition("?mconst0"))),
        // ((x:i64*(a:i64&c:i64))+(mconst0:i64*(y:i64*(a:i64&c:i64)))) => ((x:i64+(-1:i64*y:i64))*(a:i64&c:i64))
        rewrite!("merge_and_multipliers"; "(+ (* ?x (& ?a ?c)) (* ?mconst0 (* ?y (& ?a ?c))))" => {
            applier_rule_merge_and_multipliers {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
                a : "?a".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        } if (rule_merge_and_multipliers_precondition("?mconst0"))),
        // (d:i64+(mconst0:i64*(d:i64&a:i64))) => ((~a:i64)&d:i64)
        rewrite!("mba_1"; "(+ ?d (* ?mconst0 (& ?d ?a)))" => {
            applier_rule_mba_1 {
                a : "?a".parse().unwrap(),
                d : "?d".parse().unwrap(),
            }
        } if (rule_mba_1_precondition("?mconst0"))),
        // ((mconst0:i64*(d:i64&a:i64))+d:i64) => ((~a:i64)&d:i64)
        rewrite!("mba_2"; "(+ (* ?mconst0 (& ?d ?a)) ?d)" => {
            applier_rule_mba_2 {
                a : "?a".parse().unwrap(),
                d : "?d".parse().unwrap(),
            }
        } if (rule_mba_2_precondition("?mconst0"))),
        // ((d:i64|a:i64)+(mconst0:i64*(a:i64&(~d:i64)))) => d:i64
        rewrite!("mba_4"; "(+ (| ?d ?a) (* ?mconst0 (& ?a (~ ?d))))" => {
            applier_rule_mba_4 {
                d : "?d".parse().unwrap(),
            }
        } if (rule_mba_4_precondition("?mconst0"))),
        // ((mconst0:i64*(a:i64&(~d:i64)))+(d:i64|a:i64)) => d:i64
        rewrite!("mba_5"; "(+ (* ?mconst0 (& ?a (~ ?d))) (| ?d ?a))" => {
            applier_rule_mba_5 {
                d : "?d".parse().unwrap(),
            }
        } if (rule_mba_5_precondition("?mconst0"))),
        // ((a:i64+(mconst0:i64*d:i64))+(mconst1:i64*((~a:i64)&(mconst1:i64*d:i64)))) => (a:i64^(2:i64*d:i64))
        rewrite!("mba_9"; "(+ (+ ?a (* ?mconst0 ?d)) (* ?mconst1 (& (~ ?a) (* ?mconst1 ?d))))" => {
            applier_rule_mba_9 {
                a : "?a".parse().unwrap(),
                d : "?d".parse().unwrap(),
            }
        } if (rule_mba_9_precondition("?mconst0", "?mconst1"))),
        // ((x:i64^y:i64)+(mconst0:i64*(x:i64|y:i64))) => (-1:i64*(x:i64&y:i64))
        rewrite!("new_2"; "(+ (^ ?x ?y) (* ?mconst0 (| ?x ?y)))" => {
            applier_rule_new_2 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_new_2_precondition("?mconst0"))),
        // ((a:i64|b:i64)+(mconst0:i64*a:i64)) => ((~a:i64)&b:i64)
        rewrite!("new_3"; "(+ (| ?a ?b) (* ?mconst0 ?a))" => {
            applier_rule_new_3 {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        } if (rule_new_3_precondition("?mconst0"))),
        // ((a:i64^b:i64)&a:i64) => (a:i64&(~b:i64))
        rewrite!("new_16"; "(& (^ ?a ?b) ?a)" => {
            applier_rule_new_16 {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // (((~x:i64)&y:i64)+(mconst0:i64*y:i64)) => (-1:i64*(x:i64&y:i64))
        rewrite!("new_23"; "(+ (& (~ ?x) ?y) (* ?mconst0 ?y))" => {
            applier_rule_new_23 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_new_23_precondition("?mconst0"))),
        // (((~x:i64)&y:i64)+(y:i64*(mconst0:i64*mconst1:i64))) => (-1:i64*(x:i64&y:i64))
        rewrite!("new_24"; "(+ (& (~ ?x) ?y) (* ?y (* ?mconst0 ?mconst1)))" => {
            applier_rule_new_24 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_new_24_precondition("?mconst0", "?mconst1"))),
        // (mconst0:i64&(y:i64^((mconst1:i64*mconst2:i64)+y:i64))) => 0:i64
        rewrite!("opaque_constant_1"; "(& ?mconst0 (^ ?y (+ (* ?mconst1 ?mconst2) ?y)))" => {
            applier_rule_opaque_constant_1 {
                mconst0 : "?mconst0".parse().unwrap(),
            }
        } if (rule_opaque_constant_1_precondition("?mconst0", "?mconst1", "?mconst2"))),
        // ((x:i64&y:i64)+(~(x:i64&y:i64))) => -1:i64
        rewrite!("opaque_constant_1_again"; "(+ (& ?x ?y) (~ (& ?x ?y)))" => {
            applier_rule_opaque_constant_1_again {
                x : "?x".parse().unwrap(),
            }
        }),
        // ((mconst0:i64&y:i64)^(mconst0:i64&(y:i64+(mconst1:i64*mconst2:i64)))) => 0:i64
        rewrite!("opaque_constant_two"; "(^ (& ?mconst0 ?y) (& ?mconst0 (+ ?y (* ?mconst1 ?mconst2))))" => {
            applier_rule_opaque_constant_two {
                mconst0 : "?mconst0".parse().unwrap(),
            }
        } if (rule_opaque_constant_two_precondition("?mconst0", "?mconst1", "?mconst2"))),
        // ((a:i64&b:i64)|a:i64) => a:i64
        rewrite!("opaque_variable_or"; "(| (& ?a ?b) ?a)" => {
            applier_rule_opaque_variable_or {
                a : "?a".parse().unwrap(),
            }
        }),
        // ((a:i64&(~d:i64))+(d:i64&a:i64)) => a:i64
        rewrite!("opaque_variable_add"; "(+ (& ?a (~ ?d)) (& ?d ?a))" => {
            applier_rule_opaque_variable_add {
                a : "?a".parse().unwrap(),
            }
        }),
        // ((a:i64^b:i64)&(c:i64^(a:i64^(~b:i64)))) => (c:i64&(a:i64^b:i64))
        rewrite!("reduce_and_xor_negated"; "(& (^ ?a ?b) (^ ?c (^ ?a (~ ?b))))" => {
            applier_rule_reduce_and_xor_negated {
                c : "?c".parse().unwrap(),
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
            }
        }),
        // ((y:i64&(a1:i64^c1:i64))^(y:i64&x:i64)) => (y:i64&(x:i64^(a1:i64^c1:i64)))
        rewrite!("reduce_and_xor"; "(^ (& ?y (^ ?a1 ?c1)) (& ?y ?x))" => {
            applier_rule_reduce_and_xor {
                y : "?y".parse().unwrap(),
                x : "?x".parse().unwrap(),
                a1 : "?a1".parse().unwrap(),
                c1 : "?c1".parse().unwrap(),
            }
        }),
        // (((y:i64^z:i64)|(y:i64&x:i64))^y:i64) => (z:i64&(~(x:i64&y:i64)))
        rewrite!("reduced_or_or_xor"; "(^ (| (^ ?y ?z) (& ?y ?x)) ?y)" => {
            applier_rule_reduced_or_or_xor {
                z : "?z".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // (((x:i64&y:i64)+(z:i64^(x:i64|y:i64)))+(mconst0:i64*(z:i64|(~(x:i64&y:i64))))) => (-2:i64+((z:i64^x:i64)^y:i64))
        rewrite!("combine_and_add_xor_or"; "(+ (+ (& ?x ?y) (^ ?z (| ?x ?y))) (* ?mconst0 (| ?z (~ (& ?x ?y)))))" => {
            applier_rule_combine_and_add_xor_or {
                z : "?z".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_combine_and_add_xor_or_precondition("?mconst0"))),
        // ((mconst0:i64*((x:i64&y:i64)+(z:i64^(x:i64|y:i64))))+(mconst1:i64*(z:i64|(~(x:i64&y:i64))))) => (2:i64+(-1:i64*((z:i64^x:i64)^y:i64)))
        rewrite!("combine_and_add_xor_or_2"; "(+ (* ?mconst0 (+ (& ?x ?y) (^ ?z (| ?x ?y)))) (* ?mconst1 (| ?z (~ (& ?x ?y)))))" => {
            applier_rule_combine_and_add_xor_or_2 {
                z : "?z".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        } if (rule_combine_and_add_xor_or_2_precondition("?mconst0", "?mconst1"))),
        // ((y:i64^(x:i64^z:i64))+(z:i64^(y:i64&x:i64))) => (z:i64+(z:i64^(x:i64|y:i64)))
        rewrite!("pack_add_xor_or"; "(+ (^ ?y (^ ?x ?z)) (^ ?z (& ?y ?x)))" => {
            applier_rule_pack_add_xor_or {
                z : "?z".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // (z:i64&(y:i64|(z:i64^x:i64))) => (z:i64&((~x:i64)|y:i64))
        rewrite!("pack_negated_xor"; "(& ?z (| ?y (^ ?z ?x)))" => {
            applier_rule_pack_negated_xor {
                z : "?z".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // (((~x:i64)&y:i64)+(y:i64&x:i64)) => y:i64
        rewrite!("negated_and_add"; "(+ (& (~ ?x) ?y) (& ?y ?x))" => {
            applier_rule_negated_and_add {
                y : "?y".parse().unwrap(),
            }
        }),
        // (((a:i64&(~b:i64))&(~c:i64))+((a:i64&b:i64)&c:i64)) => (a:i64&(~(b:i64^c:i64)))
        rewrite!("pack_negated_and_neg_into_xor"; "(+ (& (& ?a (~ ?b)) (~ ?c)) (& (& ?a ?b) ?c))" => {
            applier_rule_pack_negated_and_neg_into_xor {
                a : "?a".parse().unwrap(),
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // ((~(b:i64|c:i64))|(b:i64&c:i64)) => (~(b:i64^c:i64))
        rewrite!("pack_neg_or_and_into_negated_xor"; "(| (~ (| ?b ?c)) (& ?b ?c))" => {
            applier_rule_pack_neg_or_and_into_negated_xor {
                b : "?b".parse().unwrap(),
                c : "?c".parse().unwrap(),
            }
        }),
        // (z:i64^(x:i64|(~(y:i64&z:i64)))) => (~(z:i64&(x:i64|(~y:i64))))
        rewrite!("combine_xor_or"; "(^ ?z (| ?x (~ (& ?y ?z))))" => {
            applier_rule_combine_xor_or {
                z : "?z".parse().unwrap(),
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
            }
        }),
        // ((y:i64&x:i64)&(x:i64^z:i64)) => ((x:i64&y:i64)&(~z:i64))
        rewrite!("pack_and_xor"; "(& (& ?y ?x) (^ ?x ?z))" => {
            applier_rule_pack_and_xor {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
                z : "?z".parse().unwrap(),
            }
        }),
        // ((~(y:i64&x:i64))&(x:i64^(z:i64^(~y:i64)))) => (~((x:i64&y:i64)|((x:i64^y:i64)^z:i64)))
        rewrite!("pack_into_negated_and_or_xor"; "(& (~ (& ?y ?x)) (^ ?x (^ ?z (~ ?y))))" => {
            applier_rule_pack_into_negated_and_or_xor {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
                z : "?z".parse().unwrap(),
            }
        }),
        // ((y:i64^(x:i64|(y:i64&(~z:i64))))+((z:i64^(x:i64^y:i64))|(x:i64&y:i64))) => (x:i64+(x:i64^(y:i64|z:i64)))
        rewrite!("linear_mba_1"; "(+ (^ ?y (| ?x (& ?y (~ ?z)))) (| (^ ?z (^ ?x ?y)) (& ?x ?y)))" => {
            applier_rule_linear_mba_1 {
                x : "?x".parse().unwrap(),
                y : "?y".parse().unwrap(),
                z : "?z".parse().unwrap(),
            }
        }),
        // ((c1:i64*(z:i64^(~(x:i64|(z:i64&y:i64)))))+((mconst0:i64*c1:i64)*((z:i64&x:i64)+(y:i64|(x:i64|(~z:i64)))))) => ((-1:i64*c1:i64)*x:i64)
        rewrite!("linear_mba_2"; "(+ (* ?c1 (^ ?z (~ (| ?x (& ?z ?y))))) (* (* ?mconst0 ?c1) (+ (& ?z ?x) (| ?y (| ?x (~ ?z))))))" => {
            applier_rule_linear_mba_2 {
                c1 : "?c1".parse().unwrap(),
                x : "?x".parse().unwrap(),
            }
        } if (rule_linear_mba_2_precondition("?mconst0"))),
    ]
}

pub struct applier_rule_or_commutativity {
    pub b: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_commutativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Or([b_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_associativity {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_associativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Or([t2, c_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_commutativity {
    pub b: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_commutativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Xor([b_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_associativity {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_associativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Xor([t2, c_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_and_commutativity {
    pub b: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_commutativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::And([b_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_and_associativity {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_associativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::And([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::And([t2, c_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_mul_commutativity {
    pub b: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_commutativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Mul([b_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_mul_associativity {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_associativity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Mul([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Mul([t2, c_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_mul_distributivity {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_distributivity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Mul([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Mul([a_id, c_id]));
        let t5 = egraph.add(SimpleAst::Add([t2, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_and_or_factor {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_or_factor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let c_id = subst[self.c];
        let t3 = egraph.add(SimpleAst::Or([b_id, c_id]));
        let t4 = egraph.add(SimpleAst::And([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_and_or_distributivity {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_or_distributivity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::And([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::And([a_id, c_id]));
        let t5 = egraph.add(SimpleAst::Or([t2, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_and_factor {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_and_factor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let c_id = subst[self.c];
        let t3 = egraph.add(SimpleAst::And([b_id, c_id]));
        let t4 = egraph.add(SimpleAst::Or([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_and_distributivity {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_and_distributivity {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Or([a_id, c_id]));
        let t5 = egraph.add(SimpleAst::And([t2, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub fn rule_cmp_i1_combine_precondition<'a>(
    c1: &'a str,
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = ((is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0))
            && (is_const(egraph, c1) && (popcount(egraph, c1) == 1)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_cmp_i1_combine {
    pub a1: Var,
    pub c1: Var,
    pub a2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_cmp_i1_combine {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a1_id = subst[self.a1];
        let bounded_width = egraph[a1_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a1_id]));
        let c1_id = subst[self.c1];
        let t3 = egraph.add(SimpleAst::And([t1, c1_id]));
        let a2_id = subst[self.a2];
        let t5 = egraph.add(SimpleAst::And([a2_id, c1_id]));
        let t6 = egraph.add(SimpleAst::Xor([t3, t5]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t8 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Ne,
            children: [t6, literal_0_id],
        });

        if egraph.union(eclass, t8) {
            vec![t8]
        } else {
            vec![]
        }
    }
}

pub fn rule_cmp_xor_i1_combine_precondition<'a>(
    c1: &'a str,
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = ((is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0))
            && (is_const(egraph, c1) && (popcount(egraph, c1) == 1)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_cmp_xor_i1_combine {
    pub x: Var,
    pub y: Var,
    pub c1: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_cmp_xor_i1_combine {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::Xor([x_id, y_id]));
        let c1_id = subst[self.c1];
        let t4 = egraph.add(SimpleAst::And([t2, c1_id]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t6 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Ne,
            children: [t4, literal_0_id],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub fn rule_neg_neq_to_eq_precondition<'a>(
    c1: &'a str,
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = ((is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0))
            && (is_const(egraph, c1) && (popcount(egraph, c1) == 1)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_neg_neq_to_eq {
    pub x: Var,
    pub c1: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_neg_neq_to_eq {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let c1_id = subst[self.c1];
        let t2 = egraph.add(SimpleAst::And([x_id, c1_id]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t4 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Eq,
            children: [t2, literal_0_id],
        });

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_lshr_const_fold {
    pub a: Var,
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_lshr_const_fold {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let c1_id = subst[self.c1];
        let c2_id = subst[self.c2];
        let t3 = egraph.add(SimpleAst::Add([c1_id, c2_id]));
        let t4 = egraph.add(SimpleAst::Lshr([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_lshr_and_combine {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_lshr_and_combine {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::And([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Lshr([t2, c_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_lshr_or_combine {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_lshr_or_combine {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Lshr([t2, c_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_lshr_xor_combine {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_lshr_xor_combine {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let c_id = subst[self.c];
        let t4 = egraph.add(SimpleAst::Lshr([t2, c_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_to_or_precondition<'a>(
    a: &'a str,
    b: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let a_id = subst[a.parse().unwrap()];
        let a = &egraph[a_id];
        let b_id = subst[b.parse().unwrap()];
        let b = &egraph[b_id];
        let precondition = ((get_known_zeroes(egraph, a) | get_known_zeroes(egraph, b))
            == (18446744073709551615
                & (18446744073709551615 >> (64 + (get_width(egraph, a) * 18446744073709551615)))));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_to_or {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_to_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_sink_select_add {
    pub t0: Var,
    pub v0: Var,
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_sink_select_add {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let t0_id = subst[self.t0];
        let bounded_width = egraph[t0_id].data.width;
        let v0_id = subst[self.v0];
        let c1_id = subst[self.c1];
        let t3 = egraph.add(SimpleAst::Add([v0_id, c1_id]));
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::Add([v0_id, c2_id]));
        let t6 = egraph.add(SimpleAst::Select {
            children: [t0_id, t3, t5],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_sink_select_mul {
    pub t0: Var,
    pub v0: Var,
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_sink_select_mul {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let t0_id = subst[self.t0];
        let bounded_width = egraph[t0_id].data.width;
        let v0_id = subst[self.v0];
        let c1_id = subst[self.c1];
        let t3 = egraph.add(SimpleAst::Mul([v0_id, c1_id]));
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::Mul([v0_id, c2_id]));
        let t6 = egraph.add(SimpleAst::Select {
            children: [t0_id, t3, t5],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_sink_select_and {
    pub t0: Var,
    pub v0: Var,
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_sink_select_and {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let t0_id = subst[self.t0];
        let bounded_width = egraph[t0_id].data.width;
        let v0_id = subst[self.v0];
        let c1_id = subst[self.c1];
        let t3 = egraph.add(SimpleAst::And([v0_id, c1_id]));
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::And([v0_id, c2_id]));
        let t6 = egraph.add(SimpleAst::Select {
            children: [t0_id, t3, t5],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_sink_select_or {
    pub t0: Var,
    pub v0: Var,
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_sink_select_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let t0_id = subst[self.t0];
        let bounded_width = egraph[t0_id].data.width;
        let v0_id = subst[self.v0];
        let c1_id = subst[self.c1];
        let t3 = egraph.add(SimpleAst::Or([v0_id, c1_id]));
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::Or([v0_id, c2_id]));
        let t6 = egraph.add(SimpleAst::Select {
            children: [t0_id, t3, t5],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_sink_select_xor {
    pub t0: Var,
    pub v0: Var,
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_sink_select_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let t0_id = subst[self.t0];
        let bounded_width = egraph[t0_id].data.width;
        let v0_id = subst[self.v0];
        let c1_id = subst[self.c1];
        let t3 = egraph.add(SimpleAst::Xor([v0_id, c1_id]));
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::Xor([v0_id, c2_id]));
        let t6 = egraph.add(SimpleAst::Select {
            children: [t0_id, t3, t5],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub fn rule_eq_to_ugt_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = ((is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0))
            && ((((is_const(egraph, c1) && is_const(egraph, c2)) && (popcount(egraph, c1) == 1))
                && (popcount(egraph, c2) == 1))
                && (get_const(egraph, c1) != get_const(egraph, c2))));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_eq_to_ugt {
    pub a: Var,
    pub c1: Var,
    pub b: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_eq_to_ugt {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let c1_id = subst[self.c1];
        let t2 = egraph.add(SimpleAst::And([a_id, c1_id]));
        let b_id = subst[self.b];
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::And([b_id, c2_id]));
        let t6 = egraph.add(SimpleAst::Or([t2, t5]));
        let t7 = egraph.add(SimpleAst::Add([c1_id, c2_id]));
        let t8 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Ult,
            children: [t6, t7],
        });

        if egraph.union(eclass, t8) {
            vec![t8]
        } else {
            vec![]
        }
    }
}

pub fn rule_factor_or_neg_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_factor_or_neg {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_or_neg {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t4 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Ne,
            children: [t2, literal_0_id],
        });

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_factor_zx_and {
    pub a: Var,
    pub b: Var,
    pub width: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_zx_and {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::And([a_id, b_id]));
        let width_id = subst[self.width];
        let t4 = egraph.add(SimpleAst::Zext([t2, width_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_factor_tr_and {
    pub a: Var,
    pub b: Var,
    pub width: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_tr_and {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::And([a_id, b_id]));
        let width_id = subst[self.width];
        let t4 = egraph.add(SimpleAst::Trunc([t2, width_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_factor_zx_or {
    pub a: Var,
    pub b: Var,
    pub width: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_zx_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));
        let width_id = subst[self.width];
        let t4 = egraph.add(SimpleAst::Zext([t2, width_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_factor_tr_or {
    pub a: Var,
    pub b: Var,
    pub width: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_tr_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));
        let width_id = subst[self.width];
        let t4 = egraph.add(SimpleAst::Trunc([t2, width_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_factor_zx_xor {
    pub a: Var,
    pub b: Var,
    pub width: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_zx_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let width_id = subst[self.width];
        let t4 = egraph.add(SimpleAst::Zext([t2, width_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_factor_tr_xor {
    pub a: Var,
    pub b: Var,
    pub width: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_tr_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let width_id = subst[self.width];
        let t4 = egraph.add(SimpleAst::Trunc([t2, width_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_factor_mul {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_factor_mul {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let c_id = subst[self.c];
        let t3 = egraph.add(SimpleAst::Add([b_id, c_id]));
        let t4 = egraph.add(SimpleAst::Mul([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_group_like_terms_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_group_like_terms {
    pub c1: Var,
    pub c2: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_group_like_terms {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Add([c1_id, c2_id]));
        let a_id = subst[self.a];
        let t4 = egraph.add(SimpleAst::Mul([t2, a_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_mul_identify {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_identify {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_1_id = egraph.add(SimpleAst::Constant {
            c: 1,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_1_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_neg_expand {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_neg_expand {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::And([x_id, y_id]));
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t4 = egraph.add(SimpleAst::Mul([t2, literal_18446744073709551615_id]));
        let t5 = egraph.add(SimpleAst::Add([x_id, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_expand {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_expand {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Add([a_id, b_id]));
        let t3 = egraph.add(SimpleAst::And([a_id, b_id]));
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t5 = egraph.add(SimpleAst::Mul([t3, literal_18446744073709551615_id]));
        let t6 = egraph.add(SimpleAst::Add([t2, t5]));

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_expand {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_expand {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Add([a_id, b_id]));
        let literal_2_id = egraph.add(SimpleAst::Constant {
            c: 2,
            width: bounded_width,
        });
        let t4 = egraph.add(SimpleAst::And([a_id, b_id]));
        let t5 = egraph.add(SimpleAst::Mul([literal_2_id, t4]));
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t7 = egraph.add(SimpleAst::Mul([t5, literal_18446744073709551615_id]));
        let t8 = egraph.add(SimpleAst::Add([t2, t7]));

        if egraph.union(eclass, t8) {
            vec![t8]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_fold {
    pub x: Var,
    pub c1: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_fold {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([x_id]));
        let c1_id = subst[self.c1];
        let t3 = egraph.add(SimpleAst::And([t1, c1_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_tr_to_cmp_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 1));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_tr_to_cmp {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_tr_to_cmp {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_1_id = egraph.add(SimpleAst::Constant {
            c: 1,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::And([x_id, literal_1_id]));
        let t3 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Eq,
            children: [t2, literal_1_id],
        });

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_merge_cmp_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
    x: &'a str,
    y: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let x_id = subst[x.parse().unwrap()];
        let x = &egraph[x_id];
        let y_id = subst[y.parse().unwrap()];
        let y = &egraph[y_id];
        let precondition = (((is_const(egraph, c1) && is_const(egraph, c2))
            && ((get_known_zeroes(egraph, c1) | get_known_zeroes(egraph, c2))
                == (18446744073709551615
                    & (18446744073709551615
                        >> (64 + (get_width(egraph, c1) * 18446744073709551615))))))
            && ((get_known_zeroes(egraph, x) | get_known_zeroes(egraph, y))
                == (18446744073709551615
                    & (18446744073709551615
                        >> (64 + (get_width(egraph, x) * 18446744073709551615))))));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_merge_cmp {
    pub x: Var,
    pub y: Var,
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_merge_cmp {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::Or([x_id, y_id]));
        let c1_id = subst[self.c1];
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::Or([c1_id, c2_id]));
        let t6 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Eq,
            children: [t2, t5],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub fn rule_merge_cmp_2_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = ((is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0))
            && ((is_const(egraph, c1) && is_const(egraph, c2))
                && ((get_known_zeroes(egraph, c1) | get_known_zeroes(egraph, c2))
                    == (18446744073709551615
                        & (18446744073709551615
                            >> (64 + (get_width(egraph, c1) * 18446744073709551615)))))));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_merge_cmp_2 {
    pub x: Var,
    pub c1: Var,
    pub y: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_merge_cmp_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let c1_id = subst[self.c1];
        let t2 = egraph.add(SimpleAst::And([x_id, c1_id]));
        let y_id = subst[self.y];
        let c2_id = subst[self.c2];
        let t5 = egraph.add(SimpleAst::And([y_id, c2_id]));
        let t6 = egraph.add(SimpleAst::Or([t2, t5]));
        let t7 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Eq,
            children: [t6, c2_id],
        });

        if egraph.union(eclass, t7) {
            vec![t7]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_eq_to_sub {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_eq_to_sub {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t3 = egraph.add(SimpleAst::Mul([b_id, literal_18446744073709551615_id]));
        let t4 = egraph.add(SimpleAst::Add([a_id, t3]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t6 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Eq,
            children: [t4, literal_0_id],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_eq_to_xor {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_eq_to_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t4 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Eq,
            children: [t2, literal_0_id],
        });

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_neq_to_sub {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_neq_to_sub {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t3 = egraph.add(SimpleAst::Mul([b_id, literal_18446744073709551615_id]));
        let t4 = egraph.add(SimpleAst::Add([a_id, t3]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t6 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Ne,
            children: [t4, literal_0_id],
        });

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_neq_to_xor {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_neq_to_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });
        let t4 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Ne,
            children: [t2, literal_0_id],
        });

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_ne_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 1));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_ne {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_ne {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::ICmp {
            predicate: Predicate::Eq,
            children: [a_id, b_id],
        });

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_mul_constant_to_left_1_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mul_constant_to_left_1 {
    pub c1: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_constant_to_left_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Mul([c1_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_mul_constant_to_left_2_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mul_constant_to_left_2 {
    pub c1: Var,
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_constant_to_left_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::Mul([a_id, b_id]));
        let t4 = egraph.add(SimpleAst::Mul([c1_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_mul_constant_to_left_3_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mul_constant_to_left_3 {
    pub c1: Var,
    pub c2: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_constant_to_left_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Mul([c1_id, c2_id]));
        let a_id = subst[self.a];
        let t4 = egraph.add(SimpleAst::Mul([t2, a_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_mul_constant_to_left_4_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mul_constant_to_left_4 {
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_constant_to_left_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Mul([c1_id, c2_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_constant_to_left_1_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_constant_to_left_1 {
    pub c1: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_constant_to_left_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Add([c1_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_constant_to_left_2_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_constant_to_left_2 {
    pub c1: Var,
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_constant_to_left_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::Add([a_id, b_id]));
        let t4 = egraph.add(SimpleAst::Add([c1_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_constant_to_left_3_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_constant_to_left_3 {
    pub c1: Var,
    pub c2: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_constant_to_left_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Add([c1_id, c2_id]));
        let a_id = subst[self.a];
        let t4 = egraph.add(SimpleAst::Add([t2, a_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_constant_to_left_4_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_constant_to_left_4 {
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_constant_to_left_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Add([c1_id, c2_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_constant_to_left_1_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_constant_to_left_1 {
    pub c1: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_constant_to_left_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::And([c1_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_constant_to_left_2_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_constant_to_left_2 {
    pub c1: Var,
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_constant_to_left_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::And([a_id, b_id]));
        let t4 = egraph.add(SimpleAst::And([c1_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_constant_to_left_3_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_constant_to_left_3 {
    pub c1: Var,
    pub c2: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_constant_to_left_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::And([c1_id, c2_id]));
        let a_id = subst[self.a];
        let t4 = egraph.add(SimpleAst::And([t2, a_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_constant_to_left_4_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_constant_to_left_4 {
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_constant_to_left_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::And([c1_id, c2_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_constant_to_left_1_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_constant_to_left_1 {
    pub c1: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_constant_to_left_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Or([c1_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_constant_to_left_2_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_constant_to_left_2 {
    pub c1: Var,
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_constant_to_left_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::Or([a_id, b_id]));
        let t4 = egraph.add(SimpleAst::Or([c1_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_constant_to_left_3_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_constant_to_left_3 {
    pub c1: Var,
    pub c2: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_constant_to_left_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Or([c1_id, c2_id]));
        let a_id = subst[self.a];
        let t4 = egraph.add(SimpleAst::Or([t2, a_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_constant_to_left_4_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_constant_to_left_4 {
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_constant_to_left_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Or([c1_id, c2_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_constant_to_left_1_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_constant_to_left_1 {
    pub c1: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_constant_to_left_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Xor([c1_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_constant_to_left_2_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_constant_to_left_2 {
    pub c1: Var,
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_constant_to_left_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let a_id = subst[self.a];
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let t4 = egraph.add(SimpleAst::Xor([c1_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_constant_to_left_3_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_constant_to_left_3 {
    pub c1: Var,
    pub c2: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_constant_to_left_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Xor([c1_id, c2_id]));
        let a_id = subst[self.a];
        let t4 = egraph.add(SimpleAst::Xor([t2, a_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_constant_to_left_4_precondition<'a>(
    c1: &'a str,
    c2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let c2_id = subst[c2.parse().unwrap()];
        let c2 = &egraph[c2_id];
        let precondition = (is_const(egraph, c1) && is_const(egraph, c2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_constant_to_left_4 {
    pub c1: Var,
    pub c2: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_constant_to_left_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let c2_id = subst[self.c2];
        let t2 = egraph.add(SimpleAst::Xor([c1_id, c2_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_neg_constant_to_left_1_precondition<'a>(
    c1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let c1_id = subst[c1.parse().unwrap()];
        let c1 = &egraph[c1_id];
        let precondition = is_const(egraph, c1);
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_neg_constant_to_left_1 {
    pub c1: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_neg_constant_to_left_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([c1_id]));

        if egraph.union(eclass, t1) {
            vec![t1]
        } else {
            vec![]
        }
    }
}

pub fn rule_arith_to_negation_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_arith_to_negation {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_arith_to_negation {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));

        if egraph.union(eclass, t1) {
            vec![t1]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_negate_to_invert_sign_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 1));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_negate_to_invert_sign {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_negate_to_invert_sign {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_head_scratcher {
    pub a: Var,
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_head_scratcher {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let d_id = subst[self.d];
        let t2 = egraph.add(SimpleAst::Mul([a_id, d_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_and_to_add {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_and_to_add {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::Add([x_id, y_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_qsynth_1_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_qsynth_1 {
    pub a: Var,
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_qsynth_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let d_id = subst[self.d];
        let t3 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, d_id]));
        let t4 = egraph.add(SimpleAst::Add([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_qsynth_2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_qsynth_2 {
    pub d: Var,
    pub v1: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_qsynth_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let d_id = subst[self.d];
        let bounded_width = egraph[d_id].data.width;
        let v1_id = subst[self.v1];
        let t2 = egraph.add(SimpleAst::Add([d_id, v1_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_qsynth_2_commutative_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_qsynth_2_commutative {
    pub d: Var,
    pub v1: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_qsynth_2_commutative {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let d_id = subst[self.d];
        let bounded_width = egraph[d_id].data.width;
        let v1_id = subst[self.v1];
        let t2 = egraph.add(SimpleAst::Add([d_id, v1_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_zero_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_zero {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_zero {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_maxint_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_maxint {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_maxint {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_18446744073709551615_id) {
            vec![literal_18446744073709551615_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_itself {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_itself {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_negated_itself {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_negated_itself {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_18446744073709551615_id) {
            vec![literal_18446744073709551615_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_zero_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_zero {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_zero {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_maxint_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_maxint {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_maxint {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));

        if egraph.union(eclass, t1) {
            vec![t1]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_itself {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_itself {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_reduce {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_reduce {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_zero_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_zero {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_zero {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_maxint_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_maxint {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_maxint {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_and_itself {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_itself {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_and_negated_itself {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_negated_itself {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_add_itself {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_itself {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_2_id = egraph.add(SimpleAst::Constant {
            c: 2,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_2_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_zero_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_zero {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_zero {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_add_cancellation_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_add_cancellation {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_cancellation {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_mul_zero_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mul_zero {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_zero {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_mul_one_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 1));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mul_one {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mul_one {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_power_zero_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 0));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_power_zero {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_power_zero {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_1_id = egraph.add(SimpleAst::Constant {
            c: 1,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_1_id) {
            vec![literal_1_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_power_one_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 1));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_power_one {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_power_one {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_minus_twice_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_minus_twice {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_minus_twice {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_negate_twice {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_negate_twice {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_bitwise_negation_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_bitwise_negation {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_bitwise_negation {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::And([t1, b_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_bitwise_negation_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_bitwise_negation {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_bitwise_negation {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::Or([t1, b_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_bitwise_negation_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_bitwise_negation {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_bitwise_negation {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::Xor([t1, b_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule___merge_inverse_bitwise_terms_19 {
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___merge_inverse_bitwise_terms_19 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let y_id = subst[self.y];
        let bounded_width = egraph[y_id].data.width;

        if egraph.union(eclass, y_id) {
            vec![y_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule___merge_inverse_bitwise_terms_20 {
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___merge_inverse_bitwise_terms_20 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let y_id = subst[self.y];
        let bounded_width = egraph[y_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Add([literal_18446744073709551615_id, y_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule___merge_inverse_bitwise_terms_21 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___merge_inverse_bitwise_terms_21 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_18446744073709551615_id) {
            vec![literal_18446744073709551615_id]
        } else {
            vec![]
        }
    }
}

pub fn rule___merge_inverse_bitwise_terms_22_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule___merge_inverse_bitwise_terms_22 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___merge_inverse_bitwise_terms_22 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule___merge_inverse_bitwise_terms_23_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule___merge_inverse_bitwise_terms_23 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___merge_inverse_bitwise_terms_23 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, y_id]));
        let t4 = egraph.add(SimpleAst::Add([x_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule___merge_inverse_bitwise_terms_24_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule___merge_inverse_bitwise_terms_24 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___merge_inverse_bitwise_terms_24 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551614_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551614,
            width: bounded_width,
        });
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t3 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, x_id]));
        let t4 = egraph.add(SimpleAst::Add([literal_18446744073709551614_id, t3]));
        let y_id = subst[self.y];
        let t6 = egraph.add(SimpleAst::Add([t4, y_id]));

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_and_move_bitwise_negation_in {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_move_bitwise_negation_in {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Neg([b_id]));
        let t3 = egraph.add(SimpleAst::Or([a_id, t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_move_bitwise_negation_in {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_move_bitwise_negation_in {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Neg([b_id]));
        let t3 = egraph.add(SimpleAst::And([a_id, t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_move_bitwise_negation_in {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_move_bitwise_negation_in {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_merge_power_same_base {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_merge_power_same_base {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let c_id = subst[self.c];
        let t3 = egraph.add(SimpleAst::Add([b_id, c_id]));
        let t4 = egraph.add(SimpleAst::Pow([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_invert_add_bitwise_not_self {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_invert_add_bitwise_not_self {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_18446744073709551615_id) {
            vec![literal_18446744073709551615_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_invert_mul_bitwise_not_self {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_invert_mul_bitwise_not_self {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_asddsasad {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_asddsasad {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_same_mult_by_minus_one_1_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_same_mult_by_minus_one_1 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_same_mult_by_minus_one_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));
        let t3 = egraph.add(SimpleAst::Xor([a_id, t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_same_mult_by_minus_one_2_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551614)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_same_mult_by_minus_one_2 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_same_mult_by_minus_one_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));
        let t3 = egraph.add(SimpleAst::Xor([a_id, t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_zero_rule_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_zero_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_zero_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_neg_xor_zero_rule_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_neg_xor_zero_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_neg_xor_zero_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_neg_xor_minus_one_rule_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_neg_xor_minus_one_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_neg_xor_minus_one_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_18446744073709551615_id) {
            vec![literal_18446744073709551615_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_negated_xor_zero_rule_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_negated_xor_zero_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_negated_xor_zero_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_xor_identity_rule_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_xor_identity_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_xor_identity_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_2_id = egraph.add(SimpleAst::Constant {
            c: 2,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_2_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_xor_identity_rule_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_xor_identity_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_xor_identity_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_2_id = egraph.add(SimpleAst::Constant {
            c: 2,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_2_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_neg_conj_identity_rule_1_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_neg_conj_identity_rule_1 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_neg_conj_identity_rule_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_neg_conj_identity_rule_2_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551614))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_neg_conj_identity_rule_2 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_neg_conj_identity_rule_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_neg_conj_identity_rule_3_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_neg_conj_identity_rule_3 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_neg_conj_identity_rule_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_neg_conj_identity_rule_4_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551614))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_neg_conj_identity_rule_4 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_neg_conj_identity_rule_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_disj_identity_rule_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_disj_identity_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_disj_identity_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_conj_identity_rule_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_conj_identity_rule {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_conj_identity_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_conj_identity_rule_1_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_conj_identity_rule_1 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_conj_identity_rule_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_conj_identity_rule_2_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551614))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_conj_identity_rule_2 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_conj_identity_rule_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_conj_identity_rule_3_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_conj_identity_rule_3 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_conj_identity_rule_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_conj_identity_rule_4_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551614))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_conj_identity_rule_4 {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_conj_identity_rule_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_conj_identity_rule_2_1_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_conj_identity_rule_2_1 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_conj_identity_rule_2_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_conj_identity_rule_2_2_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_conj_identity_rule_2_2 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_conj_identity_rule_2_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_disj_identity_rule_1_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_disj_identity_rule_1 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_disj_identity_rule_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_disj_identity_rule_2_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_disj_identity_rule_2 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_disj_identity_rule_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_disj_identity_rule_3_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_disj_identity_rule_3 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_disj_identity_rule_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_neg_disj_identity_rule_1_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_neg_disj_identity_rule_1 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_neg_disj_identity_rule_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_neg_disj_identity_rule_2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_neg_disj_identity_rule_2 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_neg_disj_identity_rule_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_sub_disj_identity_rule_1_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_sub_disj_identity_rule_1 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_sub_disj_identity_rule_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_sub_disj_identity_rule_2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_sub_disj_identity_rule_2 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_sub_disj_identity_rule_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_conj_add_conj_identity_rule {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_add_conj_identity_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_disj_conj_rule_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_disj_conj_rule {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_disj_conj_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::Or([x_id, y_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_conj_conj_disj_rule_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_conj_conj_disj_rule {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_conj_conj_disj_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::And([x_id, y_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_disj_disj_conj_rule_2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_disj_disj_conj_rule_2 {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_disj_disj_conj_rule_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;

        if egraph.union(eclass, x_id) {
            vec![x_id]
        } else {
            vec![]
        }
    }
}

pub fn rule___check_bitwise_in_sums_cancel_terms_4_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551615))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule___check_bitwise_in_sums_cancel_terms_4 {
    pub y: Var,
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___check_bitwise_in_sums_cancel_terms_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let y_id = subst[self.y];
        let bounded_width = egraph[y_id].data.width;
        let x_id = subst[self.x];
        let t2 = egraph.add(SimpleAst::Xor([x_id, y_id]));
        let t3 = egraph.add(SimpleAst::Add([y_id, t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule___check_disj_involving_xor_in_sums_rule_1 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___check_disj_involving_xor_in_sums_rule_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::And([x_id, y_id]));
        let t3 = egraph.add(SimpleAst::Xor([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Add([t2, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule___check_disj_involving_xor_in_sums_rule_2 {
    pub z: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___check_disj_involving_xor_in_sums_rule_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let z_id = subst[self.z];
        let bounded_width = egraph[z_id].data.width;
        let x_id = subst[self.x];
        let t2 = egraph.add(SimpleAst::And([z_id, x_id]));
        let y_id = subst[self.y];
        let t4 = egraph.add(SimpleAst::And([t2, y_id]));
        let t5 = egraph.add(SimpleAst::Xor([x_id, y_id]));
        let t6 = egraph.add(SimpleAst::Add([t4, t5]));

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule___check_xor_involving_disj_rule {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule___check_xor_involving_disj_rule {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([x_id]));
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::And([t1, y_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_add_negated_itself_by_two {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_negated_itself_by_two {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_or_mul_shrink_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_or_mul_shrink {
    pub c: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_mul_shrink {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c_id = subst[self.c];
        let bounded_width = egraph[c_id].data.width;
        let x_id = subst[self.x];
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::Or([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Mul([c_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_shrink {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_shrink {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_shrink_2 {
    pub b: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_shrink_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Or([b_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_shrink_3 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_shrink_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::Or([x_id, y_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_or_shrink_4 {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_or_shrink_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Or([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_mul_shrink_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_mul_shrink {
    pub c: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_mul_shrink {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c_id = subst[self.c];
        let bounded_width = egraph[c_id].data.width;
        let x_id = subst[self.x];
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::Xor([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Mul([c_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_shrink_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551614));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_shrink {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_shrink {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::Xor([x_id, y_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_xor_shrink2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_xor_shrink2 {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_shrink2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Xor([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_xor_shrink_3 {
    pub b: Var,
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_xor_shrink_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let a_id = subst[self.a];
        let t2 = egraph.add(SimpleAst::Xor([b_id, a_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_negated_xor_shrink_4 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_negated_xor_shrink_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::Xor([x_id, y_id]));
        let t3 = egraph.add(SimpleAst::Neg([t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_mul_shrink_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_mul_shrink {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_mul_shrink {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let c_id = subst[self.c];
        let t3 = egraph.add(SimpleAst::And([b_id, c_id]));
        let t4 = egraph.add(SimpleAst::Mul([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_and_shrink_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_and_shrink {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_and_shrink {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::And([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_add_shrink {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_add_shrink {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Add([a_id, b_id]));

        if egraph.union(eclass, t2) {
            vec![t2]
        } else {
            vec![]
        }
    }
}

pub fn rule_cancel_and_reduce_bitwise_subtraction_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_cancel_and_reduce_bitwise_subtraction {
    pub b: Var,
    pub a: Var,
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_cancel_and_reduce_bitwise_subtraction {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let a_id = subst[self.a];
        let d_id = subst[self.d];
        let t3 = egraph.add(SimpleAst::Neg([d_id]));
        let t4 = egraph.add(SimpleAst::And([a_id, t3]));
        let t5 = egraph.add(SimpleAst::Mul([b_id, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub fn rule_merge_and_multipliers_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_merge_and_multipliers {
    pub x: Var,
    pub y: Var,
    pub a: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_merge_and_multipliers {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, y_id]));
        let t4 = egraph.add(SimpleAst::Add([x_id, t3]));
        let a_id = subst[self.a];
        let c_id = subst[self.c];
        let t7 = egraph.add(SimpleAst::And([a_id, c_id]));
        let t8 = egraph.add(SimpleAst::Mul([t4, t7]));

        if egraph.union(eclass, t8) {
            vec![t8]
        } else {
            vec![]
        }
    }
}

pub fn rule_mba_1_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mba_1 {
    pub a: Var,
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mba_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));
        let d_id = subst[self.d];
        let t3 = egraph.add(SimpleAst::And([t1, d_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_mba_2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mba_2 {
    pub a: Var,
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mba_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));
        let d_id = subst[self.d];
        let t3 = egraph.add(SimpleAst::And([t1, d_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_mba_4_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mba_4 {
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mba_4 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let d_id = subst[self.d];
        let bounded_width = egraph[d_id].data.width;

        if egraph.union(eclass, d_id) {
            vec![d_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_mba_5_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mba_5 {
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mba_5 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let d_id = subst[self.d];
        let bounded_width = egraph[d_id].data.width;

        if egraph.union(eclass, d_id) {
            vec![d_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_mba_9_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 2))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551614)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_mba_9 {
    pub a: Var,
    pub d: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_mba_9 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let literal_2_id = egraph.add(SimpleAst::Constant {
            c: 2,
            width: bounded_width,
        });
        let d_id = subst[self.d];
        let t3 = egraph.add(SimpleAst::Mul([literal_2_id, d_id]));
        let t4 = egraph.add(SimpleAst::Xor([a_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_new_2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_new_2 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_new_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::And([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_new_3_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_new_3 {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_new_3 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let t1 = egraph.add(SimpleAst::Neg([a_id]));
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::And([t1, b_id]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_new_16 {
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_new_16 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let t2 = egraph.add(SimpleAst::Neg([b_id]));
        let t3 = egraph.add(SimpleAst::And([a_id, t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub fn rule_new_23_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_new_23 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_new_23 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::And([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_new_24_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 1))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_new_24 {
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_new_24 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::And([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub fn rule_opaque_constant_1_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
    mconst2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let mconst2_id = subst[mconst2.parse().unwrap()];
        let mconst2 = &egraph[mconst2_id];
        let precondition = ((is_const(egraph, mconst2) && const_eq(egraph, mconst2, 2))
            && ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 18446744073709551615))
                && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 1))));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_opaque_constant_1 {
    pub mconst0: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_opaque_constant_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let mconst0_id = subst[self.mconst0];
        let bounded_width = egraph[mconst0_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_opaque_constant_1_again {
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_opaque_constant_1_again {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_18446744073709551615_id) {
            vec![literal_18446744073709551615_id]
        } else {
            vec![]
        }
    }
}

pub fn rule_opaque_constant_two_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
    mconst2: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let mconst2_id = subst[mconst2.parse().unwrap()];
        let mconst2 = &egraph[mconst2_id];
        let precondition = ((is_const(egraph, mconst2) && const_eq(egraph, mconst2, 2))
            && ((is_const(egraph, mconst1) && const_eq(egraph, mconst1, 18446744073709551615))
                && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 1))));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_opaque_constant_two {
    pub mconst0: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_opaque_constant_two {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let mconst0_id = subst[self.mconst0];
        let bounded_width = egraph[mconst0_id].data.width;
        let literal_0_id = egraph.add(SimpleAst::Constant {
            c: 0,
            width: bounded_width,
        });

        if egraph.union(eclass, literal_0_id) {
            vec![literal_0_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_opaque_variable_or {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_opaque_variable_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_opaque_variable_add {
    pub a: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_opaque_variable_add {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;

        if egraph.union(eclass, a_id) {
            vec![a_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_reduce_and_xor_negated {
    pub c: Var,
    pub a: Var,
    pub b: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_reduce_and_xor_negated {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c_id = subst[self.c];
        let bounded_width = egraph[c_id].data.width;
        let a_id = subst[self.a];
        let b_id = subst[self.b];
        let t3 = egraph.add(SimpleAst::Xor([a_id, b_id]));
        let t4 = egraph.add(SimpleAst::And([c_id, t3]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_reduce_and_xor {
    pub y: Var,
    pub x: Var,
    pub a1: Var,
    pub c1: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_reduce_and_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let y_id = subst[self.y];
        let bounded_width = egraph[y_id].data.width;
        let x_id = subst[self.x];
        let a1_id = subst[self.a1];
        let c1_id = subst[self.c1];
        let t4 = egraph.add(SimpleAst::Xor([a1_id, c1_id]));
        let t5 = egraph.add(SimpleAst::Xor([x_id, t4]));
        let t6 = egraph.add(SimpleAst::And([y_id, t5]));

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_reduced_or_or_xor {
    pub z: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_reduced_or_or_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let z_id = subst[self.z];
        let bounded_width = egraph[z_id].data.width;
        let x_id = subst[self.x];
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::And([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Neg([t3]));
        let t5 = egraph.add(SimpleAst::And([z_id, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub fn rule_combine_and_add_xor_or_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition = (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 2));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_combine_and_add_xor_or {
    pub z: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_combine_and_add_xor_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let z_id = subst[self.z];
        let bounded_width = egraph[z_id].data.width;
        let literal_18446744073709551614_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551614,
            width: bounded_width,
        });
        let x_id = subst[self.x];
        let t3 = egraph.add(SimpleAst::Xor([z_id, x_id]));
        let y_id = subst[self.y];
        let t5 = egraph.add(SimpleAst::Xor([t3, y_id]));
        let t6 = egraph.add(SimpleAst::Add([literal_18446744073709551614_id, t5]));

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub fn rule_combine_and_add_xor_or_2_precondition<'a>(
    mconst0: &'a str,
    mconst1: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let mconst1_id = subst[mconst1.parse().unwrap()];
        let mconst1 = &egraph[mconst1_id];
        let precondition = ((is_const(egraph, mconst1)
            && const_eq(egraph, mconst1, 18446744073709551614))
            && (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615)));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_combine_and_add_xor_or_2 {
    pub z: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_combine_and_add_xor_or_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let z_id = subst[self.z];
        let bounded_width = egraph[z_id].data.width;
        let literal_2_id = egraph.add(SimpleAst::Constant {
            c: 2,
            width: bounded_width,
        });
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let x_id = subst[self.x];
        let t4 = egraph.add(SimpleAst::Xor([z_id, x_id]));
        let y_id = subst[self.y];
        let t6 = egraph.add(SimpleAst::Xor([t4, y_id]));
        let t7 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, t6]));
        let t8 = egraph.add(SimpleAst::Add([literal_2_id, t7]));

        if egraph.union(eclass, t8) {
            vec![t8]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_pack_add_xor_or {
    pub z: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_pack_add_xor_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let z_id = subst[self.z];
        let bounded_width = egraph[z_id].data.width;
        let x_id = subst[self.x];
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::Or([x_id, y_id]));
        let t4 = egraph.add(SimpleAst::Xor([z_id, t3]));
        let t5 = egraph.add(SimpleAst::Add([z_id, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_pack_negated_xor {
    pub z: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_pack_negated_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let z_id = subst[self.z];
        let bounded_width = egraph[z_id].data.width;
        let x_id = subst[self.x];
        let t2 = egraph.add(SimpleAst::Neg([x_id]));
        let y_id = subst[self.y];
        let t4 = egraph.add(SimpleAst::Or([t2, y_id]));
        let t5 = egraph.add(SimpleAst::And([z_id, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_negated_and_add {
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_negated_and_add {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let y_id = subst[self.y];
        let bounded_width = egraph[y_id].data.width;

        if egraph.union(eclass, y_id) {
            vec![y_id]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_pack_negated_and_neg_into_xor {
    pub a: Var,
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_pack_negated_and_neg_into_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let a_id = subst[self.a];
        let bounded_width = egraph[a_id].data.width;
        let b_id = subst[self.b];
        let c_id = subst[self.c];
        let t3 = egraph.add(SimpleAst::Xor([b_id, c_id]));
        let t4 = egraph.add(SimpleAst::Neg([t3]));
        let t5 = egraph.add(SimpleAst::And([a_id, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_pack_neg_or_and_into_negated_xor {
    pub b: Var,
    pub c: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_pack_neg_or_and_into_negated_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let b_id = subst[self.b];
        let bounded_width = egraph[b_id].data.width;
        let c_id = subst[self.c];
        let t2 = egraph.add(SimpleAst::Xor([b_id, c_id]));
        let t3 = egraph.add(SimpleAst::Neg([t2]));

        if egraph.union(eclass, t3) {
            vec![t3]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_combine_xor_or {
    pub z: Var,
    pub x: Var,
    pub y: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_combine_xor_or {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let z_id = subst[self.z];
        let bounded_width = egraph[z_id].data.width;
        let x_id = subst[self.x];
        let y_id = subst[self.y];
        let t3 = egraph.add(SimpleAst::Neg([y_id]));
        let t4 = egraph.add(SimpleAst::Or([x_id, t3]));
        let t5 = egraph.add(SimpleAst::And([z_id, t4]));
        let t6 = egraph.add(SimpleAst::Neg([t5]));

        if egraph.union(eclass, t6) {
            vec![t6]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_pack_and_xor {
    pub x: Var,
    pub y: Var,
    pub z: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_pack_and_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::And([x_id, y_id]));
        let z_id = subst[self.z];
        let t4 = egraph.add(SimpleAst::Neg([z_id]));
        let t5 = egraph.add(SimpleAst::And([t2, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_pack_into_negated_and_or_xor {
    pub x: Var,
    pub y: Var,
    pub z: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_pack_into_negated_and_or_xor {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let t2 = egraph.add(SimpleAst::And([x_id, y_id]));
        let t3 = egraph.add(SimpleAst::Xor([x_id, y_id]));
        let z_id = subst[self.z];
        let t5 = egraph.add(SimpleAst::Xor([t3, z_id]));
        let t6 = egraph.add(SimpleAst::Or([t2, t5]));
        let t7 = egraph.add(SimpleAst::Neg([t6]));

        if egraph.union(eclass, t7) {
            vec![t7]
        } else {
            vec![]
        }
    }
}

pub struct applier_rule_linear_mba_1 {
    pub x: Var,
    pub y: Var,
    pub z: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_linear_mba_1 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let x_id = subst[self.x];
        let bounded_width = egraph[x_id].data.width;
        let y_id = subst[self.y];
        let z_id = subst[self.z];
        let t3 = egraph.add(SimpleAst::Or([y_id, z_id]));
        let t4 = egraph.add(SimpleAst::Xor([x_id, t3]));
        let t5 = egraph.add(SimpleAst::Add([x_id, t4]));

        if egraph.union(eclass, t5) {
            vec![t5]
        } else {
            vec![]
        }
    }
}

pub fn rule_linear_mba_2_precondition<'a>(
    mconst0: &'a str,
) -> impl Fn(&mut EEGraph, Id, &Subst) -> bool + 'a {
    move |egraph, _, subst| {
        let mconst0_id = subst[mconst0.parse().unwrap()];
        let mconst0 = &egraph[mconst0_id];
        let precondition =
            (is_const(egraph, mconst0) && const_eq(egraph, mconst0, 18446744073709551615));
        if !precondition {
            return false;
        }
        return true;
    }
}

pub struct applier_rule_linear_mba_2 {
    pub c1: Var,
    pub x: Var,
}

impl Applier<SimpleAst, MbaAnalysis> for applier_rule_linear_mba_2 {
    fn apply_one(
        &self,
        egraph: &mut EEGraph,
        eclass: Id,
        subst: &Subst,
        _searcher_ast: Option<&PatternAst<SimpleAst>>,
        _rule_name: Symbol,
    ) -> Vec<Id> {
        let c1_id = subst[self.c1];
        let bounded_width = egraph[c1_id].data.width;
        let literal_18446744073709551615_id = egraph.add(SimpleAst::Constant {
            c: 18446744073709551615,
            width: bounded_width,
        });
        let t2 = egraph.add(SimpleAst::Mul([literal_18446744073709551615_id, c1_id]));
        let x_id = subst[self.x];
        let t4 = egraph.add(SimpleAst::Mul([t2, x_id]));

        if egraph.union(eclass, t4) {
            vec![t4]
        } else {
            vec![]
        }
    }
}
