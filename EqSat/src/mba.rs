// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - .\isle\mba.isle

#![allow(dead_code, unreachable_code, unreachable_patterns)]
#![allow(unused_imports, unused_variables, non_snake_case, unused_mut)]
#![allow(irrefutable_let_patterns, unused_assignments, non_camel_case_types)]

use crate::simple_ast::Predicate;

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn add(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn mul(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn pow(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn and(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn or(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn xor(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn neg(&mut self, arg0: AstIdx) -> SimpleAst;
    fn lshr(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn any(&mut self, arg0: AstIdx) -> SimpleAst;
    fn lookup_value(&mut self, arg0: AstIdx) -> Option<SimpleAst>;
    fn lookup_id(&mut self, arg0: &SimpleAst) -> AstIdx;
    fn constant(&mut self, arg0: u64, arg1: u8) -> SimpleAst;
    fn symbol(&mut self, arg0: u32, arg1: u8) -> SimpleAst;
    fn zext(&mut self, arg0: AstIdx, arg1: u8) -> SimpleAst;
    fn trunc(&mut self, arg0: AstIdx, arg1: u8) -> SimpleAst;
    fn icmp(&mut self, pred: Predicate, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn select(&mut self, arg0: AstIdx, arg1: AstIdx, arg2: AstIdx) -> SimpleAst;
    fn extract(&mut self, arg0: AstIdx, arg1: u8, arg2: u8) -> SimpleAst;
    fn concat(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn carry(&mut self, arg0: AstIdx, arg1: AstIdx, arg2: AstIdx) -> SimpleAst;
    fn fold_add(&mut self, arg0: AstIdx, arg1: AstIdx) -> SimpleAst;
    fn get_width(&mut self, arg0: AstIdx) -> u8;
    fn is_constant_modulo(&mut self, arg0: u64, arg1: u64, arg2: u8) -> Option<Empty>;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
    fn size_hint(&self) -> (usize, Option<usize>) {
        (0, None)
    }
}

pub trait IntoContextIter {
    type Context;
    type Output;
    type IntoIter: ContextIter<Context = Self::Context, Output = Self::Output>;
    fn into_context_iter(self) -> Self::IntoIter;
}

pub trait Length {
    fn len(&self) -> usize;
}

impl<T> Length for std::vec::Vec<T> {
    fn len(&self) -> usize {
        std::vec::Vec::len(self)
    }
}

pub struct ContextIterWrapper<I, C> {
    iter: I,
    _ctx: std::marker::PhantomData<C>,
}
impl<I: Default, C> Default for ContextIterWrapper<I, C> {
    fn default() -> Self {
        ContextIterWrapper {
            iter: I::default(),
            _ctx: std::marker::PhantomData,
        }
    }
}
impl<I, C> std::ops::Deref for ContextIterWrapper<I, C> {
    type Target = I;
    fn deref(&self) -> &I {
        &self.iter
    }
}
impl<I, C> std::ops::DerefMut for ContextIterWrapper<I, C> {
    fn deref_mut(&mut self) -> &mut I {
        &mut self.iter
    }
}
impl<I: Iterator, C: Context> From<I> for ContextIterWrapper<I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: std::marker::PhantomData,
        }
    }
}
impl<I: Iterator, C: Context> ContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}
impl<I: IntoIterator, C: Context> IntoContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    type IntoIter = ContextIterWrapper<I::IntoIter, C>;
    fn into_context_iter(self) -> Self::IntoIter {
        ContextIterWrapper {
            iter: self.iter.into_iter(),
            _ctx: std::marker::PhantomData,
        }
    }
}
impl<T, E: Extend<T>, C> Extend<T> for ContextIterWrapper<E, C> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        self.iter.extend(iter);
    }
}
impl<L: Length, C> Length for ContextIterWrapper<L, C> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(ctx: &mut C, arg0: &SimpleAst) -> Option<SimpleAst> {
    None
}
