// Univariate basis => multivariate basis
1, x, x*2, x3**3
=>
1, x, y, x**2, x*y, y**2

// Choosing the newton basis yields a lower triangular system of linear equation
Each column is x raised to ci
// Cancel some stuff out
x^0, x^1.    x^2,            x^3
1,
1, (x1-x0),
1, (x2-x0), (x2-x0)*(x2-x1),
1, (x3-x0), (x3-x0)*(x3-x1), (x3-x0)*(x3-x1)*(x3-x2),
1, (x4-x0), (x4-x0)*(x4-x1), (x4-x0)*(x4-x1)*(x4-x2), (x4-x0)*(x4-x1)*(x4-x2)*(x4-x3),
1, (x5-x0), (x5-x0)*(x5-x1), (x5-x0)*(x5-x1)*(x5-x2), (x5-x0)*(x5-x1)*(x5-x2)*(x5-x3), (x5-x0)*(x5-x1)*(x5-x2)*(x5-x3)*(x5-x4),

// The equivalent multivariate newton basis would look like this:
0, x^1,     y^1,              x^2,                     x*y                              x**2



1, : 0, 0
1, (y1-y0), : 0, 1
1, (y2-y0), (x1-x0)*, : 1, 2
1, (y3-y0), (x2-x0)*, (y3-y0)*(y3-y1)*, : 2, 3
1, (y4-y0), (x3-x0)*, (y4-y0)*(y4-y1)*, (x3-x0)*(y4-y0)*, : 3, 4
1, (y5-y0), (x4-x0)*, (y5-y0)*(y5-y1)*, (x4-x0)*(y5-y0)*, (x4-x0)*(x4-x1)*, : 4, 5
s.add((1*c[0] + 0*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
s.add((1*c[0] + 1*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
s.add((1*c[0] + 2*c[1] + 1*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 2)
s.add((1*c[0] + 3*c[1] + 2*c[2] + 6*c[3] + 0*c[4] + 0*c[5]) == 6)
s.add((1*c[0] + 4*c[1] + 3*c[2] + 12*c[3] + 12*c[4] + 0*c[5]) == 12)
s.add((1*c[0] + 5*c[1] + 4*c[2] + 20*c[3] + 20*c[4] + 12*c[5]) == 20)


# Actually wrong...


1, : 0, 0
s.add((1*c[0] + 0*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
1, (y1-y0), : 0, 1
s.add((1*c[0] + 1*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
1, (y3-y0), (x2-x0)*, (y3-y0)*(y3-y1)*, : 2, 3
s.add((1*c[0] + 2*c[1] + 1*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 2)

newton basis:
1, x, x*(x-1), x*(x-1)*(x-2)

1, x, y, x**2, x*y, y**2

1, x, y*(x-1), x*(x-1)*(y-1)


