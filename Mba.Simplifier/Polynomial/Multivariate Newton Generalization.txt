// Univariate basis => multivariate basis
1, x, x*2, x3**3
=>
1, x, y, x**2, x*y, y**2

// Choosing the newton basis yields a lower triangular system of linear equation
Each column is x raised to ci
// Cancel some stuff out
x^0, x^1.    x^2,            x^3
1, 0
1, (y-x), 1
1, (x2-x), (x2-x)*(x2-y), 2
1, (x3-x), (x3-x)*(x3-y), (x3-x)*(x3-y)*(x3-x2), 3
1, (x4-x), (x4-x)*(x4-y), (x4-x)*(x4-y)*(x4-x2), (x4-x)*(x4-y)*(x4-x2)*(x4-x3), 4
1, (x5-x), (x5-x)*(x5-y), (x5-x)*(x5-y)*(x5-x2), (x5-x)*(x5-y)*(x5-x2)*(x5-x3), (x5-x)*(x5-y)*(x5-x2)*(x5-x3)*(x5-x4), 5

// The equivalent multivariate newton basis would look like this:
0, x^1,     y^1,              x^2,                     x*y                              x**2



1, : 0, 0
1, (y1-y0), : 0, 1
1, (y2-y0), (y-x)*, : 1, 2
1, (y3-y0), (x2-x)*, (y3-y0)*(y3-y1)*, : 2, 3
1, (y4-y0), (x3-x)*, (y4-y0)*(y4-y1)*, (x3-x)*(y4-y0)*, : 3, 4
1, (y5-y0), (x4-x)*, (y5-y0)*(y5-y1)*, (x4-x)*(y5-y0)*, (x4-x)*(x4-y)*, : 4, 5
s.add((1*c[0] + 0*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
s.add((1*c[0] + 1*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
s.add((1*c[0] + 2*c[1] + 1*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 2)
s.add((1*c[0] + 3*c[1] + 2*c[2] + 6*c[3] + 0*c[4] + 0*c[5]) == 6)
s.add((1*c[0] + 4*c[1] + 3*c[2] + 12*c[3] + 12*c[4] + 0*c[5]) == 12)
s.add((1*c[0] + 5*c[1] + 4*c[2] + 20*c[3] + 20*c[4] + 12*c[5]) == 20)


# Actually wrong...


1, : 0, 0
s.add((1*c[0] + 0*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
1, (y1-y0), : 0, 1
s.add((1*c[0] + 1*c[1] + 0*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 0)
1, (y3-y0), (x2-x)*, (y3-y0)*(y3-y1)*, : 2, 3
s.add((1*c[0] + 2*c[1] + 1*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 2)

newton basis:
1, x, x*(x-1), x*(x-1)*(x-2)

1, x, y, x**2, x*y, y**2

Probably:
1, x, y*(x-1), x*(x-1)*(y-1)

Maybe:
1, x, y*(x-1), x*(x-1)*(y-1)



1, (y3-y0), (x2-x)*, (y3-y0)*(y3-y1)*, : 2, 3
s.add((1*c[0] + 2*c[1] + 1*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 2)

1, (y2-y0), (y-x)*, : 1, 2

s.add((1*c[0] + 2*c[1] + 1*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 2)


1*y == 0
y = 0

1, (y2-y0), (y-x)*, : 1, 2
s.add((1*c[0] + 2*c[1] + 1*c[2] + 0*c[3] + 0*c[4] + 0*c[5]) == 2)

2*0 + 1*c == 2

c1 + c2*(x-1) + c3*(y-1) + c4*()

HAND WRITTEN SYSTEM:
c0*1 == 0
c0*1 + c1*(x - 1) = 4234
c0*1 + c2*(x - 2) + c3*(y-2) = 334234
c0*1 + c2*(x - 3) + c3*(y-3) = 334234
c0*1 + c2*(x - 4) + c3*(y-4) + c4*(x-3)*()

=>


c0*1 == 0
c0*1 + c1*(x - 1) = 4234
c0*1 + c2*(x - 2) + c3*(y-1) = 334234
c0*1 + c2*(x - 3) + c3*(y-4) + c4*(x-2)*()


c0*1 == 0
c0*1 + c1*(x - 1) = 4234
c0*1 + c1*(x - 1) + c2*(y-1) = 334234
c0*1 + c1*(x - 1) + c2*(y-1) + c4*(x-2)*(x-1)


c0*1 == 0
c0 * 1 = whatever
c0*1 + c1*(x - 1) = 4234
c0*1 + c1*(x - 1) + c2*(y-1) = 334234
// Once they're both defined, that's when you stop zeroing stuff out... but...
c0*1 + c1*(x - 1) + c2*(y-1) + c3*(x-1)*(y-1) = 3443
c0*1 + c1*(x - 1) + c2*(y-1) + c3*(x-1)*(y-1) + c4*(x-1)*(x-2)


#There will be some point where maybe you cant evaluate a dead vcariable on zero
# Each input pair is effectively to add a new point, where variables are dead
c0*1 == 0
c0*1 + c1*(x - 1) = 4234
c0*1 + c1*(x - 1) + c2*(y-1) = 334234
c0*1 + c1*(x - 1) + c2*(y-1) + c3*(x-1)*(y-1)

c0 + c1*(x - 1) + c2*(y-1) + c3*(x-1)*(y-1)

coeff(x, y) - c0 = c1*(x - 1) + c2*(y-1) + c3*(x-1)*(y-1)

((coeff(x, y) - c0)/(x - 1)) = c1 + (c2*(y-1)/(x-1)) + c3*(y-1)

c0*1 == 0
c0*1 + c1*(x - 1) = 4234
c0*1 + c1*(x - 1) + c2*(x-1)*(x-2) = 334234
c0*1 + c1*(x - 1) + c2*(x-1)*(x-2) + c3*(x-1)*(x-2)*(x-3)


c0*1 == 0  f(1, 2)
c0*1 + c1*(x - 1) = 4234 f(2, 2)
c0*1 + c1*(x - 1) + c2*(y-2) = 334234 f(1, 3)
c0*1 + c1*(x - 1) + c2*(y-2) + c3*(x-1)*(y-2) f()

2 variable, degree 2 basis:
x0,x1,x0*x1,x0*x0,x1*x1

Apply some sorted monomial ordering. Anything that prefers lower degree terms first. 

1 (1, 2)
(x-1), (2, 2)
	(y-2), (1, 3)
		(x-1)*(y-2), (2,3)
			(x-1)*(x-2), (3,2)
				(y-2)*(y-3) (2, 4)